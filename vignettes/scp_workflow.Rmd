---
title: "Mass spectrometry-based single-cell proteomics workflow"
author: 
- name: Christophe Vanderaa
    affiliation: Computational Biology, UCLouvain
- name: Laurent Gatto
    affiliation: Computational Biology, UCLouvain
date: "29/06/2020"
output:
    html_document: 
    code_folding: hide
toc : true
toc_float : true
---

# Introduction 

Features framework

```{r load packages}
library(Features)
library(patchwork)
library(scp)
library(SingleCellExperiment)
library(tidyverse)
```

Specht et al 2019 and the toy dataset

```{r load data}
data("scp1")
```

The data contain 6 different `SingleCellExperiment` objects that we refer to 
as **assays**. Each assay contains expression data along with feature metadata.
The `SingleCellExperiment` class allows to apply cutting-edge methodologies to
the data. 

Below is an overview of the `scp1` dataset.

```{r data overview}
scp1
```

The data holds 6 assays containing PSM data acquired from 6 different MS runs. 
The first 2 assays were acquired using a TMT-11plex protocole, hence they have 
11 columns. The last 4 assays were acquired using a TMT-16plex and have 16 
columns. Each sample (column) has metadata attached to it. This can be retrieved 
using the `colData` function. 

```{r}
colData(scp1)
```

Similarly, each batch also contains features specific metadata. This is 
retrieved using the `rowDataToDF` function. The `rowData` is extracted from 
the desired assays and combined in a single table. 

```{r}
rowDataToDF(scp1, i = seq_along(scp1), vars = c("peptide", "protein"))
```

The dataset was artificially sampled so that each run contains 100 proteins. 
Each proteins has several assicated peptides, and each peptide can have several 
PSMs. This hierarchy is shown below.

```{r}
rowDataToDF(scp1, i = seq_along(scp1), vars = c("peptide", "protein")) %>%
  data.frame %>%
  rownames_to_column("PSM") %>%
  group_by(.assay) %>%
  summarize(nPSMS = n(), nPeptides = length(unique(peptide)), 
            nProteins = length(unique(protein)))
```

The workflow can be split up in the following steps:

1. Process the PSM data 
2. Aggregate PSMs to peptides
3. Join batches in a single assay
4. Filter single cells
5. Process the peptide data 
6. Aggregate peptides to proteins
7. Process the protein data
8. Differential expression analysis

Note that we will use pipe operators `\%>\%` throughout the vignette even
for single operators. This is meant to show the code shown in this vignette 
could be written with a few pipe flows (graphs excluded).

# Filter PSMs

We will start with filtering low-quality PSMs. Each PSM assay contains PSM 
metainformation stored in the assay's `rowData`. The `Features` package allows 
to quickly filter the PSMs based on those feature (PSM) information. The 
features variables for the PSM data is listed below.

```{r}
specht2019v2[[1]] %>%
  rowData %>%
  colnames
```

## Filter out contaminant, contaminated and irrelevant PSMs 

We filter out PSMs that are annotated as contaminants, that matched the decoy 
database, or that exhibit low PIF (parental ion fraction) score indicating 
contaminated spectra. Those variable are stored in the dataset as `Reverse`, 
`protein` and `PIF`, respectively.

```{r filter PSMs}
scp1 %>%
  filterFeatures(~ Reverse != "+" &
                   !grepl("REV|CON", protein) &
                   Potential.contaminant != "+" &
                   !is.na(PIF) & PIF > 0.8) -> 
  scp1
```

## Filter out failed runs based on PSM content

Next, only the assays that have sufficient PSMs are kept. Since this is a toy 
dataset, we will consider that 250 PSMs are sufficient. But this could be 
manually set based on the distribution of the number of PSMs per run and remove 
outliers on the lower end. We can easily extract the number of rows (feature, 
here PSMs) and the number of columns (samples) of each assay using the `dims` 
function implemented in `Features`.

```{r}
scp1 <- scp1[, , dims(scp1)[1, ] > 250]
scp1
```

Notice that 1 run did not fulfill the criterion and was dropped from the 
dataset.



## TO CONTINUE 








## Filter out PSMs with high sample to carrier ratio

The PSMs are next filtered based on the sample to carrier ratio (SCR), that is 
the reporter ion intensity of a single-cell sample divided by the reporter ion 
intensity of the carrier (200 cells) acquired during the same run as the sample. 
It is expected that the carrier intensities are much higher than the single-cell
intensities. We implemented the `computeSCR` function that computes the SCR for
each PSM averaged over all samples of interest in a given assay. A PSM is 
removed when the mean SCR exceeds 10 \%. To perform this, we need to tell the 
function which columns are the samples of interest and which is the carrier. 
The `colData` is used to define this. 

```{r}
colData(specht2019v2)
```

In this dataset, `CellType` gives the type of cell that is present in each TMT
channel. All the single-cells samples start with `sc` (`sc_m0`, `sc_u`, `sc_0`) 
and the carrier samples are denoted by `carrier_mix`. 

```{r}
specht2019v2 %>% 
  computeSCR(i = names(specht2019v2),
             colDataCol = "CellType",
             samplePattern = "^sc",
             carrierPattern = "carrier_mix") ->
  specht2019v2    
```

**@discussion**: 

- for some PSMs, the mean SCR is `0` (all samples are 0, but not
carrier), `NaN` (all samples and carrier are 0), or `Inf` (some samples are not 
0, but the carrier is). In my opinion, those three cases should yield `NA`. This
can be done if we already clean the missing data by replacing `0` by `NA` as 
done later on. 
- I cannot exactly replicate the mean SCR as in the paper because the batches 
63:173 contain an `unused` channel in channel 4. Our function can automatically 
detect this based on the sample pattern and exclude it whereas the SCoPE2 script 
does not. This is an error: the `unused` channels should not be used to compute 
the ratio. 

```{r}
rowDataToDF(specht2019v2, i = names(specht2019v2), vars = "meanSCR") %>%
  data.frame %>%
  ggplot(aes(x = meanSCR)) +
  geom_histogram(fill = "orange2", col = "grey40", bins = 30, na.rm = TRUE) +
  geom_vline(xintercept = 0.1, lty = "dashed") +
  scale_x_log10() +
  xlab("Mean sample to carrier ratio") +
  ggtitle("Distribution of sample to carrier ratios averaged over run")
```

A great majority of the PSMs have a mean SCR that is lower than 10\%, as 
expected. We remove the PSMs for the which the mean SCR exceeds that threshold. 

**@discussion** interesting benchmarking observation: the mode of the 
distribution is located at ~1\%. This is expected a every sample channel 
contains a single-cell and the carrier contains 200 cells leading to an expected 
mean SCR of 0.5\%. The factor 2 difference between observed and expected SCR may 
be explained by the fact that lymphocytes (composing the carrier) and the 
monocytic cells (single-cell samples)

```{r}
specht2019v2 %>%
  filterFeatures(~ !is.na(meanSCR) & 
                   !is.infinite(meanSCR) & 
                   # meanSCR != 0 &
                   meanSCR < 0.1) ->
  specht2019v2
```

## Filter out PSMs with high false discovery rate

Finally, the last PSM filter criterion is the identification false discovery 
rate (FDR). As mentioned in the introduction, the data was processed by DART-ID 
(@Chen2019-uc), a python software that updates the confindence in peptide 
identification using an Bayesian inference approach. DART-ID outputs for every 
PSM the updated posterior error probability (PEP). Filtering on the PEP is too 
conservative (@Kall2008-hb) so we compute the FDR from the PEP. First, let's 
have a look at the PEP distribution.

```{r}
rowDataToDF(specht2019v2, i = names(specht2019v2), vars = "dart_PEP") %>%
  data.frame %>%
  ggplot(aes(x = dart_PEP)) +
  geom_histogram(fill = "orange2", col = "grey40", bins = 30, na.rm = TRUE) +
  scale_x_log10() +
  xlab("PEP") +
  ggtitle("Distribution of the (DART-ID) posterior error probability")
```

We compute the FDR grouped over peptide-charge from the PSM PEPs. Again, we implemented 
a function to peform this. The PEP information as well as the peptide grouping 
ID are contained the `rowData` of each assay. So we need to supply the name of the 
variables that hold this information, `dart_PEP` and `peptide`, respectively. 

```{r}
specht2019v2 %>% 
  computeFDR(i = names(specht2019v2), 
             groupCol = "peptide",
             pepCol = "dart_PEP") ->
  specht2019v2
```

Note that a new variable `.FDR` containing the computed FDRs is added to the 
`rowData`. This allows us to easily plot the updated FDRs. 

```{r}
rowDataToDF(specht2019v2, i = names(specht2019v2), vars = c("peptide", ".FDR")) %>%
  data.frame %>%
  ggplot +
  geom_histogram(aes(x = .FDR), 
                 fill = "orange2", col = "grey40", bins = 30, na.rm = TRUE) +
  scale_x_log10() +
  xlab("FDR") +
  ggtitle("Distribution of the peptide FDR across all assays")
```

**@discussion**: I'm a bit lost here. First, even if mentioned in @Kall2008-hb, 
I don't get why we need to compute an FDR. Is it because the PSMs are not 
independent and we correct for this? Second, why are we grouping over 
peptide-charge instead of just peptide. Is the FDR ion-specific rather than 
peptide specific?

The computed FDR doesn't change from the DART-ID updated PEPs. Note that this 
is due to the fact that most peptides (with specific ion charge) in a run are 
represented by a single PSM. We filter the PSMs that have an associated peptide 
FDR smaller than 1 \%.

```{r}
specht2019v2 %>%
  filterFeatures(~ .FDR < 0.01) ->
  specht2019v2
```

# Process the PSM data

Up to now the data are composed of PSMs level intensities split over different 
runs. We will now combine all this information in a single assay and aggregate
the data over peptide-charge. 

## Relative reporter ion intensity

In order to correct for between-run variation, the authors compute relative 
reporter ion intensity. This means that intensities measured for single-cell are
divided by the reference channel, a channel containing 5-cell equivalents. We 
use the `divideByReference` function that will automatically divided the 
single-cell sample columns by the reference channel column using the annotation 
contained in the `colData`. Single-cell channel annotation starts with `sc` and 
the reference channel is annotated either as `norm` or `reference`. The assay 
values will be overwritten by the divided values. 

```{r}
specht2019v2 %>%
  divideByReference(i = names(specht2019v2), 
                    colDataCol = "CellType", 
                    samplePattern = "^sc", 
                    refPattern = "norm|reference") ->
  specht2019v2
```


# Aggregate PSM data to peptide data

Now that the PSM assays are processed, we can aggregate them to peptides. This 
is performed using the `aggregateFeaturesOverAssays` function. This is a wrapper
function we wrote that sequentially calls for different assays the 
`aggregateFeatures` from the `Features` package. This is a very useful function 
that will combine several rows (PSMs) into a single row (peptide) given an 
aggregating variable in the `rowData` (peptide sequence) and an aggregating 
function (the median for instance). Regarding the aggregating function, we 
implemented the `.remove.duplicates` function that will take the first 
non-missing value as it is performed in SCoPE2.

```{r, results='hide'}
specht2019v2 %>%
  aggregateFeaturesOverAssays(i = names(specht2019v2), 
                              fcol = "peptide", 
                              name = paste0("peptides_", names(specht2019v2)),
                              fun = .remove.duplicates) ->
  specht2019v2
```

**@TODO**: this took ~ 30 min, but could be so much faster!

**@discussion** this steps is similar to the step in SCoPE2 at line 244 + 252.
Why should we keep only the first occurence (this is basically what happens 
when we remove duplicates). As sugested by Laurent, would a weighted mean not be 
better suited (weights based on pep, PIF, distance from apex, ...) ? 

Note that under the hood, the `Features` architecture preserves the relationship 
between the aggregated assays. See `?AssayLinks` for more information on 
relationships between assays.

# Join the SCoPE2 sets in one assay

We kept the data belonging to each MS run in separate assays. We will now 
combine all batches in a single assay. This can easily be done using the 
`joinAssays` function from the `Features` package. 

We however need to acount for an issue. The `joinAssays` will only keep the 
metadata values that have the same value between matching rows and columns. 
However, some peptide sequences map to one protein in one run and to another 
protein in another run. Hence, the protein sequence is not constant across 
peptides and is removed during joining, but we will later need the protein 
sequence to aggregate peptides to proteins. To avoid this issue, we remove such 
problematic peptides.

```{r}
specht2019v2 %>%
  rowDataToDF(grep("^peptides_", names(.)), c("peptide", "protein")) %>%
  data.frame %>%
  group_by(peptide) %>%
  summarize(nProteins = length(unique(protein)))
  filter(nProteins == 1) %>%
  pull(peptide) ->
  pepKeep
specht2019v2 %>%
  filterFeatures(~ peptide %in% pepKeep) ->
  specht2019v2
```

After removing those peptides, we can join the assays. We join all the peptide
assays. Those assays start with `peptides_` and can be easily retrieved with
regular expression (regex) using the `grep` function.

```{r}
specht2019v2 %>%
    joinAssays(i = grep("^peptides_", names(.))[1:3], 
               name = "peptides") -> 
    tmp
specht2019v2[["peptides"]] <- as(specht2019v2[["peptides"]], "SingleCellExperiment")
```

**@TODO**: remove last line when the PR is merged to master in `Feature`

**@discussion**: 

* How should we correctly handle the issue that the same peptide can be mapped 
to different proteins depending on the batch? In our workflow we remove the 
problematic peptides and in SCoPE2 the issue is not addressed, but is there a 
better solution? Note that some peptides map up to 4 different proteins.
* We will continue assuming we are working with peptide data, but in fact we 
work with ion data (peptide sequence + charge). Shouldn't we better continue 
with peptide data only, hence aggregate over `Sequence` (= peptide sequence) 
instead of `peptide` (= `Sequence` + `_` + `Charge`) ?

# Filter single-cells

Specht and colleagues filter the single-cell based on 2 criteria: the median 
relative intensities per cell and the median coefficient of variation (CV) per 
cell. 

## Filter based on the median relative intensity

We compute the median relative reporter ion intensity for each cell separately 
and apply a filter based on this statistic. This procedure recalls that 
library size filtering commonly performed in scRNA-Seq data analysis, where the 
library size is the sum of the counts in each single cell. We will store the 
median intensity in the `colData` of the `peptides` assay. Note that this is not 
the same as the `colData` of the `specht2019v2` object. The later contains the 
annotation that holds for all assay (typically cell type or batch covariates). 
The `colData` of the assay hold annotation that is specific to that assay. Here,
the medians per cell computed at the peptide level are specific to peptides and 
are not valid at PSM level. You could see this as Matryoshka dolls were 
`peptides` is a small doll contained in the bigger `specht2019v2` doll.

```{r}
specht2019v2[["peptides"]] %>%
  assay %>%
  colMedians(na.rm = TRUE) ->
  specht2019v2[["peptides"]]$MedianRI
```

Looking at the distribution of the median per cell can highlight low-quality
cells. We here combine the `colData` from the `peptide` assay giving the median 
intensity per cell with the `colData` of the `specht2019v2` data containing the 
sample annotation. The authors of SCoPE2 used a threshold of 0.02 on the median 
intensity. This is indicated by the dashed line. 

```{r}
specht2019v2[["peptides"]] %>%
  colData %>%
  cbind(colData(specht2019v2)[rownames(.), ]) %>%
  data.frame %>%
  mutate(CellType = recode(CellType, 
                           sc_0 = "empty",
                           sc_u = "single-cell",
                           sc_m0 = "single-cell",
                           unused = "unused",
                           norm = "reference",
                           carrier_mix = "carrier")) %>%
  ggplot(aes(x = MedianRI, y = ..count.., fill = CellType)) +
  geom_density(col = "grey40", alpha = 0.7, na.rm = TRUE) +
  geom_vline(xintercept = 0.02, lty = "dashed") +
  scale_x_log10() + 
  xlab("Median") +
  ggtitle("Distribution of the median intensity per cell")
```

The distribution of the median intensities display interesting properties of the 
data. (i) Recall that only the single-cell and the empty samples were divided by 
the reference channel. This is shown by an important shift for those samples and 
their mode is located between 0.1 and 1 (expectation is 0.2). (ii) The 
ratio between reference channel and carrier channel is also close to the 
expected shift of 0.025. (iii) The distribution within each channel type is 
multimodal, indicating the presence of strong batch effects. We can zoom in on 
the carrier channel and include batch information. Notice this difference is 
expected since the SCoPE2 data switch from a TMT-11plex protocol (sort day s8)
to a TMT-16plex protocole (sort day s9).

```{r}
specht2019v2[["peptides"]] %>%
  colData %>%
  cbind(colData(specht2019v2)[rownames(.), ]) %>%
  data.frame %>%
  filter(CellType == "carrier_mix") %>%
  ggplot(aes(x = MedianRI, y = ..count.., fill = sortday)) +
  geom_density(col = "grey40", alpha = 0.7, na.rm = TRUE) +
  scale_x_log10() + 
  xlab("Median") +
  ggtitle("Distribution of the median intensity per cell")
```

We filter out the cells that have a median RI smaller than 0.02.

```{r}
sel <- colData(specht2019v2[["peptides"]])$MedianRI > 0.02
sel[is.na(sel)] <- FALSE
specht2019v2 %>%
  addAssay(y = specht2019v2[["peptides"]][, sel], 
           name = "peptides_MedianFilter") %>%
  addAssayLink(from = "peptides", to = "peptides_MedianFilter", 
               varFrom = "peptide", varTo = "peptide") ->
  specht2019v2
```

## Clean the data (should be before)

We also performed an additional cleaning step were zero values are replaced by 
NAs. This is also done in SCoPE2. The `zeroIsNA` function is provided by the 
`Features` package.

```{r}
specht2019v2 %>%
  infIsNA(i = "peptides_MedianFilter") %>%
  zeroIsNA(i = "peptides_MedianFilter") ->
  specht2019v2
```

**@discussion**: the first filter is performed when zero and infinite values 
are still present, whereas they should be replaced by 0. This biases the median
values and hence the following filtering steps.The cleaning step should occure before aggregation. 


## Filter based on the median CV

The median CV measures the consistency of quantification for a group of peptides 
that belong to a protein. We remove cells that exhibit high median CV over the 
different proteins. We compute the median CV using the code below.

```{r}
longFormat(specht2019v2[, , "peptides:MedianFilter"], i = 1,
           colDataCols = c("CellType", "Set")) %>%
  data.frame %>%
  select(-assay, -colname) %>%
  cbind(rowData(specht2019v2[["peptides"]])[.$rowname, c("peptide", "protein")]) %>%
  group_by(primary) %>%
  mutate(norm_q1 = value / median(value, na.rm = TRUE)) %>%
  group_by(peptide, Set) %>%
  ## Note that here we do not replicate the original results because of the 1
  ## peptide to several protein issue (see `Aggregate PSM data to peptide 
  ## data`)
  mutate(norm_q = value / mean(norm_q1, na.rm = TRUE)) %>%
  filter(startsWith(CellType, "sc")) %>%
  group_by(protein, primary) %>%
  mutate(norm_q_sd = sd(norm_q, na.rm = TRUE),
         norm_q_mean = mean(norm_q, na.rm = TRUE),
         cvq = norm_q_sd / norm_q_mean) %>%
  group_by(protein, primary) %>%
  mutate(cvn = sum(!is.na(norm_q))) %>%
  filter(cvn > 5) %>%
  group_by(primary) %>%
  mutate(MedianCV = median(cvq, na.rm = TRUE)) -> 
  filterDf
```

**@discussion**: this code is almost copy-pasted from the SCoPE2 analysis and I
just adapted the variable names to match our data. I should create a dedicate 
function to compute median CVs. The isssue is I don't get the intuition on what 
is happening here, namely why do we compute `norm_q`? Also see the comment in 
the code about peptide mathcing issue.

The data frame we generated holds the compute median CVs computed using at 
least 5 observations (peptides). The distribution of the median CV per cell is 
depicted below.

```{r}
filterDf %>%
  filter(!duplicated(primary)) %>%
  mutate(CellType = recode(CellType, 
                           sc_0 = "empty",
                           sc_u = "single-cell",
                           sc_m0 = "single-cell")) %>%
  ggplot(aes(x = MedianCV, fill = CellType)) +
  geom_histogram(bins = 25, position = "dodge") +
  geom_vline(xintercept = 0.5, lty = "dashed")
```

We can see that the protein quantifiation for single-cell are much more 
consistent within cells than the empty channels. In the original analysis, the 
authors noticed that a threshold of 0.5 on the mediand CV best separates the 
single cell samples from the empty channels. Since we could not fully replicate 
the data, we observe that a threshold of 0.5 is best. 

Similarly to the median intensity, we include the median CV in the `colData` of
the `peptides` assay. 

```{r}
filterDf %>%
  select(primary, MedianCV) %>%
  unique ->
  CVs
colData(specht2019v2[["peptides:MedianFilter"]])$MedianCV <- NA
colData(specht2019v2[["peptides:MedianFilter"]])[CVs$primary, "MedianCV"] <- CVs$MedianCV
```

**@TODO** include the step in the standardized function as discussed above

In the end, we keep the cells that have a median intensity higher than 0.02 and
a median CV lower than 0.5. We also remove the carrier, reference, unused and
empty channels to keep only the single-cell samples of interest. We store the
filtered data in a separate assay using the `addAssay` function and include the 
one-to-one relationships between the rows of the two assays using the 
`addAssayLinkOneToOne`. 

```{r}
sel <- 
  !is.na(specht2019v2[["peptides:MedianFilter"]]$MedianCV) &
  specht2019v2[["peptides:MedianFilter"]]$MedianCV < 0.5 & 
  ## Keep only macrophaes and monocytes
  colData(specht2019v2)[colnames(specht2019v2[["peptides:MedianFilter"]]), "CellType"] != "sc_0"
specht2019v2 %>%
  addAssay(name = "peptides_filt",
           y = specht2019v2[["peptides:MedianFilter"]][, sel]) %>%
  addAssayLinkOneToOne(from = "peptides:MedianFilter", 
                       to = "peptides_filt") ->
  specht2019v2
```

# Process the peptide data

In the SCoPE2 analysis, the peptide data is first transformed before aggregated 
to proteins. The transformation steps are: normalization, filter peptides based 
on missing data and log-transformation.

## Normalization

The columns (samples) of the peptide data are first normalized by dividing the 
relative intensities by the median relative intensities. Then, the rows 
(peptide features) are normalized by dividing the relative intensities by the 
mean relative intensities. The normalized data is stored in a separate assay. 

```{r}
specht2019v2 %>%
  addAssay(y = specht2019v2[["peptides_filt"]], name = "peptides_norm") %>%
  addAssayLinkOneToOne(from = "peptides_filt", 
                       to = "peptides_norm") %>%
  ## Center columns with median
  scp_normalize(i = "peptides_norm",  margin = 2, 
                method = function(x) x / median(x, na.rm = TRUE)) %>%
  ## Center rows with mean
  scp_normalize(i = "peptides_norm",  margin = 1, 
                method = function(x) x / mean(x, na.rm = TRUE)) ->
  specht2019v2
```

**@todo**: when PR is merged, use the `sweep` method from `Features`

**@discussion**: why using median for columns and mean for rows?

## Remove peptides with high missing rate

Peptides that contain many missing values are not informative. Therefore, we
remove those with more than 99 \% missing data. This is done using the 
`filterNA` function from `Features`.

```{r}
specht2019v2 %>%
  filterNA(i = "peptides_norm", 
           pNA = 0.99) -> 
  specht2019v2
```

## Log-transformation 

The last processing step of the peptide data before aggregating to proteins is 
to log-transform the data. SCoPE2 uses a base 2 log-transformation. 

```{r}
specht2019v2 %>%
  logTransform(base = 2,
               i = "peptides_norm", 
               name = "peptides_log") ->
  specht2019v2
```

The `peptide_log` assay should be identical to the peptide data provided by 
Specht et al. We will compare the two data tables later in this vignette to 
benchmark the replication results.

# Aggregate peptide data to protein data

Similarly to aggregating PSM data to peptide data, we can aggregate peptide data
to protein data using the `aggregateFeatures` function. Note that we here use 
the median as a summarizing function. 
```{r}
specht2019v2 %>%
  aggregateFeatures(i = "peptides_log",  
                    name = "proteins", 
                    fcol = "protein", 
                    fun = matrixStats::colMedians, na.rm = TRUE) ->
  specht2019v2
```

# Process the protein data

The protein data is processed in three steps: normalization, imputation (using 
the KNN algorithm) and batch correction (using the ComBat algorithm).

## Normalization 

Normalization is performed similarly to peptide normalization. We use the same 
functions, but since the data were log-transformed at the peptide level, we 
subtract by the statistics (median or mean) instead of dividing. 

```{r}
specht2019v2 %>%
  addAssay(y = specht2019v2[["proteins"]], 
           name = "proteins_norm") %>%
  addAssayLinkOneToOne(from = "proteins", 
                       to = "proteins_norm") %>%
  ## Center columns with median
  scp_normalize(i = "proteins_norm",  
                margin = 2, 
                method = function(x) x - median(x, na.rm = TRUE)) %>%
  ## Center rows with mean
  scp_normalize(i = "proteins_norm",  
                margin = 1, 
                method = function(x) x - mean(x, na.rm = TRUE)) ->
  specht2019v2
```
**@todo**: replace scp_normalize with Features:sweep

## Imputation

The protein data contains a lot of missing values. The graph below shows the 
rate of missingness in proteins found in macrophages versus undifferenciated 
monocytes. 

```{r}
longFormat(specht2019v2[, , "proteins_norm"]) %>%
  data.frame %>%
  group_by(colname) %>%
  summarize(x = mean(is.na(value)) * 100) %>%
  ggplot() +
  geom_histogram(aes(x = x), fill = "orange2", col = "grey30") +
  xlab("% missing data") +
  ggtitle("Distribution of the amount of missing data within cells")
```


The missing data is imputated using K nearest neighbors. Specht and colleagues 
used k = 3. We made a wrapper around the author's code to apply imputation to 
our `Features` object. 

```{r}
specht2019v2 %>%
  scp_imputeKNN(i = "proteins_norm", 
                name = "proteins_impd") ->
  specht2019v2
```


## Batch correction

The final steps is to model the remaining batch effects and correct for it. The 
`ComBat` algorithm is here used, and we again created a wrapper around it to 
work with `Features` objects 

```{r}
specht2019v2 %>%
  transferColDataToAssay(i = "proteins_impd") %>%
  scp_ComBat(i = "proteins_impd", 
             name = "proteins_batchC",
             batch = "Set", 
             mod = ~ CellType) -> 
  specht2019v2
```

The `proeteins_impd` data corresponds to the protein dataset provided by the 
authors. This is the final step of the data reproduction workflow. 

```{r echo=FALSE}
save(filterDf, specht2019v2, peptides, proteins, file = "final.RData")
```


# Benchmarking the replication

## Compare peptide data

Subset peptide data to match the processed sets.

```{r}
batches <- unique(colData(specht2019v2)[colnames(specht2019v2[["peptides_filt"]]), "Set"])
peptidesv1 <- peptides[, peptides$Set %in% batches]
peptidesv1 <- peptidesv1[apply(assay(peptidesv1), 1, function(x) mean(is.na(x)) < 0.99), ]
```


```{r}
dim(peptidesv1)
dim(specht2019v2[["peptides_log"]])
```

More peptides but less samples.

```{r}
allPeps <- unique(c(rownames(peptidesv1), rownames(specht2019v2[["peptides_log"]])))
table(peptidesSCoPE2 = allPeps %in% rownames(peptidesv1), 
      peptidesSCP = allPeps %in% rownames(specht2019v2[["peptides_log"]]))
```

```{r}
allCells <- unique(c(colnames(peptidesv1), colnames(specht2019v2[["peptides_log"]])))
table(peptidesSCoPE2 = allCells %in% colnames(peptidesv1), 
      peptidesSCP = allCells %in% colnames(specht2019v2[["peptides_log"]]))
```

```{r}
bind_rows(longFormat(peptidesv1) %>% 
            mutate(source = "SCoPE2"), 
          longFormat(specht2019v2[["peptides_log"]]) %>%
            mutate(source = "SCP")) %>%
  ggplot +
  geom_histogram(aes(x = value)) +
  facet_grid(rows = vars(source))
```

The profiles are higly similar. 


## Compare protein data

Subset peptide data to match the processed sets.

```{r}
batches <- unique(colData(specht2019v2)[colnames(specht2019v2[["proteins_batchC"]]), "Set"])
proteinsv1 <- proteins[, proteins$Set %in% batches]
proteinsv1 <- proteinsv1[apply(assay(proteinsv1), 1, function(x) mean(is.na(x)) < 0.99), ]
```


```{r}
dim(proteinsv1)
dim(specht2019v2[["proteins_batchC"]])
```

Less proteins and less samples.

```{r}
allProts <- unique(c(rownames(proteinsv1), rownames(specht2019v2[["proteins_batchC"]])))
table(ProteinsSCoPE2 = allProts %in% rownames(proteinsv1), 
      ProteinsSCP = allProts %in% rownames(specht2019v2[["proteins_batchC"]]))
```

Overlap here is pretty bad...

```{r}
bind_rows(longFormat(proteinsv1) %>% 
            mutate(source = "SCoPE2"), 
          longFormat(specht2019v2[["proteins_batchC"]]) %>%
            mutate(source = "SCP")) %>%
  ggplot +
  geom_histogram(aes(x = value)) +
  facet_grid(rows = vars(source))
```

The profiles are less similar than for peptides. 

## Reproduce the SCoPE2 figures

### Figure 2.b

```{r}
filterDf %>%
  select(primary, MedianCV, CellType) %>%
  mutate(CellType = recode(CellType, 
                           sc_0 = "empty",
                           sc_u = "single-cell",
                           sc_m0 = "single-cell")) %>%
  unique %>%
  ggplot +
  geom_density(aes(x = MedianCV, fill = CellType), alpha = 0.5) +
  xlab("Quantification variability") +
  ylab("Density") +
  scale_fill_manual(values = c( "black", "purple2")) +
  theme_minimal()
```

This is different from the original figure. As addressed during the cell 
filtering step, we could not exactly reproduce the CV calculation because of the
peptide to protein mapping issue. 

### Figure 3.a

To assess the separability between macrophages and monocytes, Specht and 
colleagues perform weighted PCA on the protein data. The weights are 
proportional to the amount of correlation between a protein and the other 
proteins. 

```{r}
X <- assay(specht2019v2[["proteins_batchC"]])
w <- rowSums(cor(t(X))^2)
Xw <- diag(w) %*%  X
Xcor <- cor(Xw)
pcaRes <- eigen(Xcor)
pcaPercentVar <- round(pcaRes$values[1:2] / sum(pcaRes$values) * 100, 2)
data.frame(PC = pcaRes$vectors[, 1:2], 
           colData(specht2019v2)[colnames(Xcor), ]) %>%
  ggplot(aes(x = PC.1, y = PC.2, col = CellType)) +
  xlab(paste0("PC1 (", pcaPercentVar[1], "%)")) +
  ylab(paste0("PC2 (", pcaPercentVar[2], "%)")) +
  geom_point(alpha = 0.5) +
  scale_color_manual(name = "", values = c("#048ABF","#FF5733"), 
                     labels = c("Macrophages", "Monocytes")) +
  theme(legend.position = "top") +
  ggtitle("PCA plot of the processed protein data") +
  theme_minimal()
```

Classical PCA for single-cell data can easily be performed using the `scater` 
package.

```{r}
library(scater)
specht2019v2[["proteins_batchC"]] = as(specht2019v2[["proteins_batchC"]], "SingleCellExperiment")
specht2019v2[["proteins_batchC"]] %>%
  runPCA(ncomponents = 50, 
         ntop = Inf, 
         scale = TRUE, 
         exprs_values = 1, 
         name = "PCA") %>%
  plotPCA(colour_by = "CellType")
```


### Figure 4.a

The histogram at the top of the plot gives the spectral ordering based on the 
Fiedler vector. The Fiedler vector is the eigen vector of the Laplacian matrix
$L$ associated to the smallest non-zero (considering numerical precision) 
eigenvalue. 

```{r}
W <- 1 + Xcor
D <- diag(rowSums(W))
L <- D - W
eigs<-eigen(L)
specht2019v2[["proteins_batchC"]]$fiedler <- 
  eigs$vectors[, order(eigs$values, decreasing = FALSE)[2]]
```

The Fiedler vector extracts the main component of cell variability. 

```{r}
colData(specht2019v2[["proteins_batchC"]]) %>%
  data.frame() %>%
  arrange(-fiedler) %>%
  mutate(index = 1:nrow(.)) %>%
  ggplot() +
  geom_bar(aes(x = index, y = fiedler, fill = CellType), 
           stat = "identity", width = 1, alpha = 0.7)  +
  scale_fill_manual(values = c("#048ABF","#FF5733"), name = "", 
                    labels = c("Macrophages", "Monocytes")) +
  xlab("Cell index") +
  theme_minimal() +
  theme(legend.position = "top") ->
  fiedlerPlot
fiedlerPlot
```


We try too reproduce the heatmap but not enough info. 

```{r}
## Order cells by the fiedler vector
specht2019v2[["proteins_batchC"]] %>%
  colData %>%
  data.frame %>%
  rownames_to_column("cells") %>%
  arrange(-fiedler) %>%
  pull(cells) ->
  cOrd
## Order and subset proteins by the difference expression between spectrum extremes
specht2019v2[["proteins_batchC"]] %>%
  .[, cOrd] %>%
  assay ->
  mat
data.frame(proteins = rownames(mat),
           medLow = rowMedians(mat[, 1:40], na.rm = TRUE),
           medHigh = rowMedians(mat[, rev(1:ncol(mat))[1:40]], na.rm = TRUE)) %>%
  mutate(lfc = medLow - medHigh, 
         sign = sign(lfc)) %>%
  arrange(sign, abs(lfc)) %>% 
  filter(abs(lfc) > quantile(abs(lfc), 0.8)) %>%
  pull(proteins) -> 
  pOrd
## Plot as heatmap
specht2019v2[["proteins_batchC"]][pOrd, cOrd] %>%
  longFormat %>%
  mutate(rowname = factor(rowname, levels = pOrd),
         colname = factor(colname, levels = cOrd),
         value = ifelse(value > 2, 2, value), 
         value = ifelse(value < -2, -2, value)) %>%
  ggplot(aes(x = colname, y = rowname, fill = value)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("blue",rgb(0,0,1,0.5),"white",rgb(1,0,0,0.5),"red")) +
  theme_minimal() +
  theme(axis.text = element_blank(), legend.position = "none") +
  xlab("Cell index") +
  ylab("Proteins") ->
  heatmapPlot
heatmapPlot
```

Create the figure 4.a

```{r}
fiedlerPlot + 
  scale_x_continuous(expand = c(0, 0)) +
  theme(axis.text = element_blank(), legend.position = "none", 
        axis.title.x = element_blank(), panel.grid = element_blank()) +
  heatmapPlot +
  plot_layout(heights = c(0.2, 0.8), ncol = 1)
```


### Figure 4.b

```{r}
protAnnot <- c(P29966 = "MARCKS",
               Q9UIG0 = "BAZ1B",
               P19338 = "NCL",
               P08670 = "VIM",
               P07355 = "ANXA2",
               O94964 = "SOGA1")
specht2019v2[["proteins_batchC"]] %>%
  assay %>%
  t %>%
  .[, names(protAnnot)] %>%
  data.frame(., colData(specht2019v2[["proteins_batchC"]])) %>%
  rename_with(.fn = function(x) protAnnot[x], .col = names(protAnnot)) %>%
  mutate(CellType = ifelse(CellType == "sc_u", "Monocyte", "Macrophage")) %>%
  pivot_longer(cols = any_of(unname(protAnnot)), names_to = "Protein", 
               values_to = "x") %>%
  mutate(Protein = factor(Protein, levels = protAnnot)) %>%
  ggplot(aes(x = x, fill = CellType)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~ Protein, nrow = 1, scales = "free_x") +
  ylab("") +
  xlab("Protein level, log2") +
  coord_flip() + 
  scale_fill_manual(values = c("#048ABF","#FF5733")) +
  theme_minimal() +
  theme(axis.text.x = element_blank()) ->
  protDensityPlot
protDensityPlot
```


### Figure S.2.b

```{r}
rowDataToDF(specht2019v2,  i = 1:173, vars = c("peptide", "protein")) %>%
  data.frame %>%
  pivot_longer(cols = c("peptide", "protein"), names_to = "type", 
               values_to = "sequence") %>%
  group_by(sequence, .assay) %>%
  summarise(type = unique(type), .groups = "keep") %>%
  group_by(type, .assay) %>%
  summarise(n = n(), .groups = "keep") %>%
  ggplot +
  geom_violin(aes(x = type, y = n), fill = "black", adjust = 0.5, scale = "width") +
  xlab("") +
  ylab("Number IDs per run") +
  theme_minimal()
```


## Interesting plots

```{r, fig.asp=1}
longFormat(specht2019v2[, , "peptides_filt"], i = 1, colDataCols = "CellType") %>%
  data.frame %>%
  rename(Protein = rowname) %>%
  group_by(CellType, Protein) %>%
  summarize(pNA = sum(is.na(value))/n() * 100) %>%
  pivot_wider(id_cols = Protein, names_from = CellType, values_from = pNA) %>%
  mutate(logFC = sc_m0 - sc_u) %>%
  ggplot -> 
  p
p +
  geom_histogram(aes(x = sc_m0), binwidth = 5) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  plot_spacer() + 
  p + 
  geom_point(aes(x = sc_m0, y = sc_u, col = logFC)) +
  theme(legend.position = "bottom") +
  xlab("Missingness (%) in macrophages") +
  ylab("Missingness (%) in monocytes") +
  scale_color_gradient2(low = "#048ABF", mid = "bisque2", high = "#FF5733") +
  p +
  geom_histogram(aes(y = sc_u), binwidth = 5) +
  theme_minimal() +
  theme(axis.title.y = element_blank(), axis.text.y = element_blank(),
        axis.ticks.y = element_blank(), 
        axis.text.x = element_text(angle = -90, vjust = 0.5, hjust=0)) +
  plot_layout(widths = c(0.9, 0.1), heights = c(0.1, 0.9))
```


# Reference
