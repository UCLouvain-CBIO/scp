
####---- Description ----#### 

# This script is a modified version of the script called
# "scp/inst/20191115-Specht 2019/replicate specht/replicate specht 2019 - clean.R"
# where the key processing steps are identified. The objective is to get the 
# best possible separation between monocytes and macrophages (as depicted in 
# their article).

# The data can be downloaded from: 
# https://drive.google.com/drive/folders/1LQicnfUFUBkzrRkHRTmUjO-aDXI0dvSO

library(MSnbase)
setwd("./inst/20191115-Specht 2019/replicate specht/")
source("../../../R/utils.R")


####---- Specht et al. results ----####

# Create the PCA with the data as generated by Specht et al. This dataset is 
# on the cleaned version of their script.
# Note: the data is filtered, normalized, log2 transformed, but not merged to 
# protein level, imputed, batch corrected.
load("../extdata/specht2019.RData")
pca0 <- nipals(exprs(specht2019), ncomp = 5, center = TRUE, scale = TRUE)
customPCA(specht2019, pca, x = "PC1", y = "PC2", color = "samp_type", shape = "lcbatch")
customPCA(specht2019, pca, x = "PC1", y = "PC3", color = "samp_type", shape = "lcbatch")

# Conclusion: there is a very large batch effect seen in PC1 and PC2, but some
# of the varation is also depending on cell type and contained in PC3.

# The idea is now to come up with another (more intuitive) processing step or to 
# identify what are the key steps for achieving/improving this PCA separation 
# between cell types and eventually avoid the batch effects. 


####---- Load the data ----####

# Load meta data
samp <- read.csv("../extdata/annotation_fp60-97.csv", 
                 row.names = 1, check.names = F)
batch <- read.csv("../extdata/batch_fp60-97.csv", 
                  row.names = 1)

# Load the data and create an MSnSet
mq_file <- "../extdata/ev_updated.txt"
coln <- colnames(read.table(mq_file, header = TRUE, sep = "\t", nrow = 1))
sc0 <- readMSnSet2(file = mq_file, fnames = "id", sep = "\t", header = TRUE,
                   ecol = grep("intensity[.]\\d", coln, value = TRUE))
sc <- sc0


####---- Add a peptide sequence-charge field ----####

fData(sc)$sequence_charge <- paste0(fData(sc)$Modified.sequence, fData(sc)$Charge)


####---- Filter based on run annotation ----####

# Keep only sc runs and runs that have associated sample metadata

sel <- !grepl("blank|_QC_|col19|col2[0-4]", fData(sc)$Raw.file)
# sc.runs <- unique(fData(sc)$Raw.file[sel])
# Keep only experiments FP94 and FP97 (the other single cell experiments exhibit 
# higher missingness)
sc <- sc[sel & grepl("FP9[47]", fData(sc)$Raw.file), ]


####---- Filter based on identification measures ----####

# Remove the reverse hits (from decoy database) and contaminants
sc <- sc[fData(sc)$Reverse != "+", ]
sc <- sc[!grepl("^REV", fData(sc)$Leading.razor.protein), ]
sc <- sc[fData(sc)$Potential.contaminant != "+", ]
sc <- sc[fData(sc)$PIF > 0.8 & !is.na(fData(sc)$PIF), ]

# Remove spectra with poor identification confidence
# The PEP and q-values were updated using DART-ID
# TODO discuss with Laurent ! Why not deleting peptides with high FDR instead of 
# deleting the proteins for which all associated peptides have high FDR 
qprots <- unique(fData(sc)$Leading.razor.protein[fData(sc)$dart_qval < 0.01])
sc <- sc[fData(sc)$Leading.razor.protein %in% qprots, ]
sc <- sc[fData(sc)$dart_PEP < 0.02, ]

# Remove runs with insufficient identified peptides 
pep.t <- table(fData(sc)$Raw.file)
sc <- sc[fData(sc)$Raw.file %in% names(pep.t[pep.t >= 300]),] 


####--- Filter based on sample to carrier ratio ----####

# This is only performed single cell runs
sc <- scp_filterSCR(sc, samples = 4:11, carrier = 1, thresh = 0.1)


####---- Numeric normalization ----####

# Normalize single cell runs to normalization channel
sc_nn <- scp_normalize_rRI(sc, ref_col = 2)

# Normalize single cell runs to carrier
# TODO: discuss with Laurent ! Here the carrier normalization is performed after reference normalization !! 
sc_nc <- scp_normalize_rRI(sc_nn, ref_col = 1)


####---- Format data to a peptide x sample matrix ----####

.keep <- c("Raw.file", "sequence_charge", "Modified.sequence", "Sequence", 
           "Length", "Proteins", "Leading.razor.protein", "Gene.names", 
           "Protein.names", "Mass")

## Reference normalized data

# Convert data to long format 
sc_nn <- scp_exprsToLong(sc_nn, f_sel = .keep)
# Remove duplicates
sc_nn <- sc_nn[!duplicated(fData(sc_nn)[, c("sequence_charge", "Raw.file", "channel")]), ]
# Convert data to wide format
sc_nn0 <- scp_exprsToWide(sc_nn)

## Carrier normalized data

# Convert data to long format 
sc_nc <- scp_exprsToLong(sc_nc, f_sel = .keep)
# Remove duplicates
sc_nc <- sc_nc[!duplicated(fData(sc_nc)[, c("sequence_charge", "Raw.file", "channel")]), ]
# Convert data to wide format
sc_nc0 <- scp_exprsToWide(sc_nc)

####---- Missing data cleaning ----####

# Replace zero's by NA
sc_nn <- scp_cleanMissing(sc_nn0, misVal = NA)
sc_nc <- scp_cleanMissing(sc_nc0, misVal = NA)


####---- Add sample metadata ----####

pd <- data.frame(row.names = sampleNames(sc_nn))
pd$run <- sapply(rownames(pd), function(x) strsplit(x, "-")[[1]][1])
pd$channel <- sapply(rownames(pd), function(x) strsplit(x, "-")[[1]][2])
pd$samp_type <- sapply(1:nrow(pd), function(i) samp[pd$channel[i], pd$run[i]])
pd <- cbind(pd, batch[pd$run, ])
pData(sc_nn) <- pd
pData(sc_nc) <- pd


####---- Keep only single cell data ----####

sel <- pData(sc_nn)$samp_type %in% c("sc_u","sc_m0", "sc_0") &
  pData(sc_nn)$run %in% sc.runs
sc_nn <- sc_nn[, sel]
sc_nc <- sc_nc[, sel]
sc_nc_lb <- sc_nc_lb[, sel]


####--- Filter based on data distributions ----####


sc_nnf <- scp_filterDD(sc_nn, sc_nn, 
                       rowNorm = TRUE, npep = 6, 
                       qprobs = 0.3, q_thres = -2.5,
                       cv_thres = 0.43, 
                       median_thres = -1.3,
                       Plot = TRUE)
# Note1: I was not able to reproduce the CV calculation but had something very 
# similar
# Note2: npep has no big impact on the CV distribution, but row normalization 
# does!
# Note3: The distributions change a lot whether we use the carrier 
# normalized or the reference normalized data 
# Note4: performing quantile and median RI filtering makes no big difference 
# applied on the 0->0.001 data or the 0->NA data. Hence the 3rd argument can be 
# dropped

hist(exprs(sc_nnf), breaks = "FD", xlim = c(0, 0.04), col = "darkseagreen")


####---- Normalize rows and columns ----####

sc_nnfn <- scp_normalize_stat(sc_nnf, what = "column", fun = "/", stats = median)
sc_nnfn <- scp_normalize_stat(sc_nnfn, what = "row", fun = "/", stats = mean)

hist(exprs(sc_nnfn), breaks = "FD", xlim = c(-2, 2), col = "darkseagreen")


####---- Filter based on missingness ----####

sc_nnfn <- scp_filterNA(sc_nnfn, "row", pNA = 0.99)
sc_nnfn <- scp_filterNA(sc_nnfn, "column", pNA = 0.99)

hist(exprs(sc_nnfn), breaks = "FD", xlim = c(-2, 2), col = "darkseagreen")


####---- Log2 transform ----####

sc_final <- log(sc_nnfn, base = 2)

hist(exprs(sc_final), breaks = "FD", xlim = c(-2, 2), col = "darkseagreen")


####---- Update PCA ----####

# Skip transformation if needed
sc_final <- sc_nnfn
sc_final <- sc_nnfn[, !pData(sc_nnfn)$samp_type %in% c("carrier_mix", "norm", "unused")]
sc_final <- scp_filterNA(sc_final, "row", pNA = 0.999999)

pca <- nipals(exprs(sc_final), ncomp = 5, center = TRUE, scale = TRUE)
customPCA(sc_final, pca, x = "PC1", y = "PC3", color = "samp_type", shape = "lcbatch")

# Note1: The column and row normalization step is ESSENTIAL to separate the 2 
# cell types. Interstingly, this step also increases the batch effect ! 
# Note2: normalization of both rows and columns by the median leads to 
# issues when solving the PCA...
# Note3: normalization of both rows and columns by the median leads to 
# issues when solving the PCA...
# Note4: normalizing columns then rows or row then columns has an impact on the 
# PCA where the former leads to separation in PC2 whereas the latter leads to 
# separation in PC4
# Note5: using the carrier normalized data only (sc_nc) does also work !
# Note6: the data dependent filtering removes cells that seem to overlap with 
# the opposite cell type population and removes the empty wells. 

