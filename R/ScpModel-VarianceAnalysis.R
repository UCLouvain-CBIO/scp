
## ---- SCP Variance Analysis ----

##' @name ScpModel-VarianceAnalysis
##'
##' @title Analysis of variance for single-cell proteomics
##'
##' @description
##'
##' Analysis of variance investigates the contribution of each effects
##' in capturing the variance in the data.
##'
##' @section Running the variance analysis:
##'
##' `scpVarianceAnalysis()` computes the amount of data (measured as
##' the sums of squares) that is captured by each model variable, but
##' also that is not modelled and hence captured in the residuals. The
##' proportion of variance explained by each effect is the sums of 
##' squares for that effect divided by the sum of all sums of squares
##' for each effect and residuals. This is computed for each feature
##' separately. The function returns a list of `DataFrame`s with one
##' table for each effect.
##'
##' `scpVarianceAggregate()` combines the analysis of variance results
##' for groups of features. This is useful, for example, to 
##' return protein-level results when data is modelled at the peptide
##' level. The function takes the list of tables generated by
##' `scpVarianceAnalysis()` and returns a new list of `DataFrame`s 
##' with aggregated results. 
##'
##' @section Exploring variance analysis results:
##'
##' [scpAnnotateResults()] adds annotations to the component
##' analysis results. The annotations are added to all elements of the
##' list returned by `scpComponentAnalysis()`. See the associated man
##' page for more information.
##' 
##' `scpVariancePlot()` takes the list of tables generated by
##' `scpVarianceAnalysis()` and returns a `ggplot2` bar plot. The
##' bar plot shows the proportion of explained variance by each effect
##' and the residual variance. By default, the function will combine
##' the results over all features, showing the effect's contributions
##' on the complete data set. When `combine = FALSE`, the results
##' are shown for individual features, with additional arguments to
##' control how many and which features are shown. Bars can also be
##' grouped by `fcol`. This is particularly useful when exploring 
##' peptide level results, but grouping peptides that belong to the
##' same protein (note that you should not use `scpVarianceAggregate()`
##' in that case). 
##'
##' @seealso
##'
##' - [ScpModel-Workflow] to run a model on SCP data upstream of 
##'   analysis of variance.
##' - [scpAnnotateResults()] to annotate analysis of variance results.
##'
##' @author Christophe Vanderaa, Laurent Gatto
##'
##' @example inst/examples/examples_ScpModel-VarianceAnalysis.R
##' 
NULL

## ---- Analysis functions ----

##' @name ScpModel-VarianceAnalysis
##'
##' @param object An object that inherits from the 
##'     `SingleCellExperiment` class. It must contain an estimated
##'     `ScpModel` in its metadata.
##'
##' @param name A `character(1)` providing the name to use to retrieve
##'     the model results. When retrieving a model and `name` is
##'     missing, the name of the first model found in `object` is used.
##'     
##' @export
scpVarianceAnalysis <- function(object, name) {
    ss <- .computeSumsOfSquares(object, name)
    denom <- .explainedVarianceDenominator(ss)
    df <- scpModelDf(object, name)
    out <- lapply(colnames(ss[, -1]), function (i) {
        DataFrame(
            feature = rownames(ss),
            SS = ss[, i],
            df = df[rownames(ss)],
            percentExplainedVar = ss[, i] / denom * 100
        )
    })
    names(out) <- colnames(ss[, -1])
    List(out)
}

## Internal function that compute the sums of squares for each effect
## in a model, as well as the residual SS and the toal SS. The results
## are returned in a table with the different SS as columns and 
## features as rows
.computeSumsOfSquares <- function(object, name) {
    name <- .checkModelName(object, name)
    SStotal <- .computeTotalSS(object, name)
    SSresiduals <- .computeResidualSS(object, name)
    SSmodel <- .computeEffectSS(object, name)
    cbind(SStotal, Residuals = SSresiduals, SSmodel)
}

## Internal function that computes the total SS for a model by
## computing the Euclidean norm of the input data after intercept
## removal. Missing values are ignored.
.computeTotalSS <- function(object, name) {
    Y <- scpModelInput(object, name)
    intercept <- scpModelIntercept(object, name)
    Y <- sweep(Y, STATS = intercept, MARGIN = 1, FUN = "-")
    rowSums(Y^2, na.rm = TRUE)
}

## Internal function that computes the residual SS for a model by
## computing the Euclidean norm of the residuals. Missing values are
## ignored.
.computeResidualSS <- function(object, name) {
    R <- scpModelResiduals(object, name, join = TRUE)
    rowSums(R^2, na.rm = TRUE)
}

## Internal function that computes the SS captured by each model 
## variable for a model by computing the Euclidean norm of each 
## effect matrix. Missing values are ignored.
.computeEffectSS <- function(object, name) {
    sapply(scpModelEffects(object, name), function(x){
        rowSums(x^2, na.rm = TRUE)
    })
}

## Internal function that returns whether the given coefficient names
## from an effect. We need a complex pattern in case of interaction
## and factors with > 2 levels.
.isCoefficientInEffect <- function(coefficients, effect) {
    pattern <- paste0("^[^\\^:*]*",
                      gsub("[:]", "[^\\^:*]*:", effect),
                      "[^\\^:*]*$")
    sel <- grepl(pattern, coefficients)
    if (!sum(sel)) stop("Effect not found")
    sel
}

## Internal function that decides how the denominator is computed when
## computing the proportion of explained variance. When
## useTotalSS = TRUE, equation 24 in Thiel et al. 2017 is used. When
## useTotalSS = FALSE, equation 26 in Thiel et al. 2017 is used.
.explainedVarianceDenominator <- function(ss, useTotalSS = FALSE) {
    if (useTotalSS) {
        denom <- ss[, "SStotal"]
    } else {
        denom <- rowSums(ss[, colnames(ss) != "SStotal"])
    }
    denom
}

## ---- Aggregation functions ----

##' @name ScpModel-VarianceAnalysis
##' 
##' @param varianceList A list of tables returned by
##'     `scpVarianceAnalysis()`.
##'
##' @param fcol A `character(1)` indicating the column to use for 
##'     grouping features. Typically, this would be protein or gene
##'     names for grouping proteins.
##' 
##' @export
scpVarianceAggregate <- function(varianceList, fcol) {
    stopifnot(fcol %in% colnames(varianceList[[1]]))
    endoapply(varianceList, function(x) {
        x <- x[!is.na(x[[fcol]]), ]
        out <- reduceDataFrame(x, x[[fcol]], count = TRUE)
        out$SS <- sapply(out$SS, sum, na.rm = TRUE)
        out$df <- sapply(out$df, sum, na.rm = TRUE)
        out$percentExplainedVar <- 
            sapply(out$percentExplainedVar, mean, na.rm = TRUE)
        out$feature <- out[[fcol]]
        out
    })
}


## ---- Plotting functions ----

##' @name ScpModel-VarianceAnalysis
##'
##' @param effect A `character(1)` used to filter theb results. It 
##'     indicates which effect should be considered when sorting the
##'     results.
##'
##' @param by A `character(1)` used to filter the results. It 
##'     indicates which variable should be considered when sorting the
##'     results. Can be one of: "SS", "df", or "percentExplainedVar".
##'
##' @param top A `numeric(1)` used to filter the results. It indicates how
##'     many features should be plotted. When `top = Inf` (default),
##'     all feature are considered.
##'
##' @param decreasing A `logical(1)` indicating whether the effects 
##'     should be ordered decreasingly (`TRUE`, default) or 
##'     increasingly (`FALSE`) depending on the value provided by
##'     `by`.
##'
##' @param combined A `logical(1)` indicating whether the results
##'     should be combined across all features. When `TRUE`, the 
##'     barplot shows the explained variance for the complete dataset.
##'
##' @param colourSeed A `integer(1)` providing a seed that is used
##'     when randomly sampling colours for the effects. Change the 
##'     number to generate another colour scheme. 
##' 
##' @import ggplot2
##' @export
scpVariancePlot <- function(varianceList,
                            effect = "Residuals",
                            by = "percentExplainedVar",
                            top = Inf,
                            decreasing = TRUE,
                            combined = TRUE,
                            fcol = NULL,
                            colourSeed = 1234) {
    varianceTable <- .gatherVarianceData(varianceList)
    varianceTable <- .filterVarianceData(
        varianceTable, top, by, effect, decreasing
    )
    levs <- unique(varianceTable$effectName)
    levs <- c("Residuals", levs[levs != "Residuals"])
    varianceTable$effectName <- factor(
        varianceTable$effectName, levels = levs
    )
    set.seed(colourSeed)
    pl <- if (combined) {
        .plotExplainedVarianceCombined(varianceTable)
    } else {
        .plotExplainedVarianceByFeature(varianceTable, fcol)
    }
    pl <- pl + labs(x = "", y = "Explained variance")
    pl <- .prettifyVariancePlot(pl)
    pl
}

.gatherVarianceData <- function(varianceTables) {
    out <- lapply(names(varianceTables), function(effect) {
        varianceTable <- varianceTables[[effect]]
        varianceTable$effectName <- effect
        varianceTable
    })
    do.call(rbind, out)
}

.filterVarianceData <- function(varianceTable, top, by, effect, 
                                decreasing) {
    stopifnot(by %in% colnames(varianceTable))
    stopifnot(effect %in% varianceTable$effectName)
    if (top > nrow(varianceTable)) top <- nrow(varianceTable)
    isEffect <- varianceTable[["effectName"]] == effect
    criteria <- varianceTable[[by]][isEffect]
    topIndex <- order(criteria, decreasing = decreasing)[seq_len(top)]
    topFeatures <- varianceTable$feature[topIndex]
    varianceTable <-varianceTable[varianceTable$feature %in% topFeatures, ]
    varianceTable$feature <- factor(
        varianceTable$feature, 
        levels = topFeatures
    )
    varianceTable
}

.plotExplainedVarianceByFeature <- function(varianceTable, 
                                            fcol = NULL) {
    if (!is.null(fcol)) varianceTable$fcol <- varianceTable[[fcol]]
    pl <- ggplot(as.data.frame(varianceTable)) +
        aes(
            fill = .data$effectName,
            y = .data$percentExplainedVar,
            x = .data$feature
        ) +
        geom_bar(
            colour = "black",
            stat = "identity"
        )
    if (!is.null(fcol)){
        pl <- pl + facet_grid(~ fcol, scales = "free_x", space = "free")   
    }
    pl
}

##' @importFrom dplyr group_by summarise
.plotExplainedVarianceCombined <- function(varianceTable) {
    varianceTable <- group_by(
        as.data.frame(varianceTable), .data$effectName
    )
    varianceTable <- summarise(
        varianceTable, percentExplainedVar = mean(.data$percentExplainedVar)
    )
    ggplot(varianceTable) +
        aes(fill = .data$effectName, 
            y = .data$percentExplainedVar, 
            x = 1) +
        geom_bar(colour = "black", stat = "identity")
}

##' @import RColorBrewer
.prettifyVariancePlot <- function(pl) {
    ## Set2 is colour blind friendly
    cols <- brewer.pal(n = 8, name = "Set2")
    ncols <- length(unique(pl$data$effectName)) - 1
    cols <- sample(cols, ncols, replace = ncols > 8)
    pl <- pl +
        theme_classic() +
        theme(
            axis.text.x = element_text(
                angle = 90, hjust = 1, vjust = 0.5
            ),
            axis.ticks.x = element_blank(),
            axis.line.x = element_blank()
        )
    pl <- pl + scale_fill_manual(
        values = c("white", cols), 
        name = "Effect name"
    )
    if (identical(pl$mapping$x, 1)) {
        pl <- pl + theme(axis.text.x = element_blank())
    }
    pl
}
