<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Single Cell Proteomics data processing and analysis. • scp</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Single Cell Proteomics data processing and analysis.">
<meta property="og:description" content="scp">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">scp</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/scp.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/UCLouvain-CBIO/scp/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="scp_files/header-attrs-2.6/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Single Cell Proteomics data processing and analysis.</h1>
                        <h4 data-toc-skip class="author">Laurent Gatto</h4>
                                    <h4 data-toc-skip class="author">Christophe Vanderaa</h4>
                        
            <h4 data-toc-skip class="date">17 February 2021</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/UCLouvain-CBIO/scp/blob/master/vignettes/scp.Rmd"><code>vignettes/scp.Rmd</code></a></small>
      <div class="hidden name"><code>scp.Rmd</code></div>

    </div>

    
    
<div id="the-scp-package" class="section level1">
<h1 class="hasAnchor">
<a href="#the-scp-package" class="anchor"></a>The <code>scp</code> package</h1>
<p>The <code>scp</code> package is used to process and analyse mass spectrometry (MS)-based single cell proteomics (SCP) data. The functions rely on a specific data structure that wraps <a href="https://rformassspectrometry.github.io/QFeatures/"><code>QFeatures</code></a> objects (<span class="citation">Gatto (2020)</span>) around <a href="http://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html"><code>SingleCellExperiment</code></a> objects (<span class="citation">Amezquita et al. (2019)</span>). This data structure could be seen as Matryoshka dolls were the <code>SingleCellExperiment</code> objects are small dolls contained in the bigger <code>QFeatures</code> doll.</p>
<p>The <code>SingleCellExperiment</code> class provides a dedicated framework for single-cell data. The <code>SingleCellExperiment</code> serves as an interface to many cutting-edge methods for processing, visualizing and analysis single-cell data. More information about the <code>SingleCellExperiment</code> class and associated methods can be found in the <a href="http://bioconductor.org/books/release/OSCA/">OSCA book</a>.</p>
<p>The <code>QFeatures</code> class is a data framework dedicated to manipulate and process MS-based quantitative data. It preserves the relationship between the different levels of information: peptide to spectrum match (PSM) data, peptide data and protein data. The <code>QFeatures</code> package also provides an interface to many utility functions to streamline the processing MS data. More information about MS data analysis tools can be found in the <a href="https://www.rformassspectrometry.org/">RforMassSpectrometry project</a>.</p>
<div class="figure" style="text-align: center">
<img src="figures/SCP_framework.png" alt="`scp` relies on `SingleCellExperiment` and `QFeatures` objects." width="100%"><p class="caption">
<code>scp</code> relies on <code>SingleCellExperiment</code> and <code>QFeatures</code> objects.
</p>
</div>
<p>Before running the vignette we need to load the <code>scp</code> package.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://UCLouvain-CBIO.github.io/scp">"scp"</a></span><span class="op">)</span></code></pre></div>
<p>We also load <code>ggplot2</code>, <code>magrittr</code> and <code>dplyr</code> for convenient data manipulation and plotting.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://ggplot2.tidyverse.org">"ggplot2"</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://magrittr.tidyverse.org">"magrittr"</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://dplyr.tidyverse.org">"dplyr"</a></span><span class="op">)</span></code></pre></div>
</div>
<div id="before-you-start" class="section level1">
<h1 class="hasAnchor">
<a href="#before-you-start" class="anchor"></a>Before you start</h1>
<p>This vignette will guide you through some common steps of mass spectrometry-based single-cell proteomics (SCP) data analysis. SCP is an emerging field and further research is required to develop a principled analysis workflow. Therefore, we <strong>do not guarantee</strong> that the steps presented here are the best steps for this type of data analysis. This vignette performs the steps that were described in the SCoPE2 landmark paper (<span class="citation">Specht et al. (2021)</span>). We hope to convince the reader that, although the workflow is probably not optimal, <code>scp</code> has the full potential to perform standardized and principled data analysis. All functions presented here are comprehensively documented, highly modular, can easily be extended with new algorithms. Suggestions, feature requests or bug reports are warmly welcome. Feel free to open an issue in the <a href="https://github.com/UCLouvain-CBIO/scp/issues">GitHub repository</a>.</p>
</div>
<div id="read-in-scp-data" class="section level1">
<h1 class="hasAnchor">
<a href="#read-in-scp-data" class="anchor"></a>Read in SCP data</h1>
<p>The first step is to read in the PSM quantification table generated by, for example, MaxQuant (<span class="citation">Tyanova, Temu, and Cox (2016)</span>). We created a small example data by subsetting the MaxQuant <code>evidence.txt</code> table provided in the SCoPE2 landmark paper (<span class="citation">Specht et al. (2021)</span>). The <code>mqScpData</code> table is a typical example of what you would get after reading in a CSV file using <code>read.csv</code> or <code>read.table</code>. See <code><a href="../reference/mqScpData.html">?mqScpData</a></code> for more information about the table content.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"mqScpData"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">)</span>
<span class="co">#&gt; [1] 1097  149</span>
<span class="va">mqScpData</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>
<span class="co">#&gt;                                                                            uid</span>
<span class="co">#&gt; 1       _(Acetyl (Protein N-term))ALSDADVQK_ 2 0.0042795 190222S_LCA9_X_FP94BM</span>
<span class="co">#&gt; 2       _(Acetyl (Protein N-term))ASSDIQVK_ 2 0.0052312 190321S_LCA10_X_FP97AG</span>
<span class="co">#&gt; 3         _(Acetyl (Protein N-term))ASSDIQVK_ 2 0.017122 190222S_LCA9_X_FP94BM</span>
<span class="co">#&gt; 4        _(Acetyl (Protein N-term))SSSPVNVK_ 2 0.0058549 190222S_LCA9_X_FP94BM</span>
<span class="co">#&gt; 5  _(Acetyl (Protein N-term))SSSPVNVK_ 2 0.047975 190914S_LCB3_X_16plex_Set_21</span>
<span class="co">#&gt; 6                             _AAAASPR_ 2 0.53163 190914S_LCB3_X_16plex_Set_21</span>
<span class="co">#&gt; 7                      _AADPPAENSSAPEAEQGGAE_ 3 0.015944 190222S_LCA9_X_FP94BM</span>
<span class="co">#&gt; 8                                  _AAIGLLAR_ 2 0.23439 190321S_LCA10_X_FP97AG</span>
<span class="co">#&gt; 9                                   _AAPASTK_ 2 0.42206 190321S_LCA10_X_FP97AG</span>
<span class="co">#&gt; 10                            _AAPASTK_ 2 0.47383 190914S_LCB3_X_16plex_Set_21</span>
<span class="co">#&gt;                Sequence Length           Modifications</span>
<span class="co">#&gt; 1             ALSDADVQK      9 Acetyl (Protein N-term)</span>
<span class="co">#&gt; 2              ASSDIQVK      8 Acetyl (Protein N-term)</span>
<span class="co">#&gt; 3              ASSDIQVK      8 Acetyl (Protein N-term)</span>
<span class="co">#&gt; 4              SSSPVNVK      8 Acetyl (Protein N-term)</span>
<span class="co">#&gt; 5              SSSPVNVK      8 Acetyl (Protein N-term)</span>
<span class="co">#&gt; 6               AAAASPR      7              Unmodified</span>
<span class="co">#&gt; 7  AADPPAENSSAPEAEQGGAE     20              Unmodified</span>
<span class="co">#&gt; 8              AAIGLLAR      8              Unmodified</span>
<span class="co">#&gt; 9               AAPASTK      7              Unmodified</span>
<span class="co">#&gt; 10              AAPASTK      7              Unmodified</span>
<span class="co">#&gt;                       Modified.sequence</span>
<span class="co">#&gt; 1  _(Acetyl (Protein N-term))ALSDADVQK_</span>
<span class="co">#&gt; 2   _(Acetyl (Protein N-term))ASSDIQVK_</span>
<span class="co">#&gt; 3   _(Acetyl (Protein N-term))ASSDIQVK_</span>
<span class="co">#&gt; 4   _(Acetyl (Protein N-term))SSSPVNVK_</span>
<span class="co">#&gt; 5   _(Acetyl (Protein N-term))SSSPVNVK_</span>
<span class="co">#&gt; 6                             _AAAASPR_</span>
<span class="co">#&gt; 7                _AADPPAENSSAPEAEQGGAE_</span>
<span class="co">#&gt; 8                            _AAIGLLAR_</span>
<span class="co">#&gt; 9                             _AAPASTK_</span>
<span class="co">#&gt; 10                            _AAPASTK_</span></code></pre></div>
<p>In order to convert this tabular data to a <code>scp</code>-compatible <code>QFeatures</code> object, we need to provide a <strong>metadata table</strong> where rows contain sample information and columns must contain at least:</p>
<ul>
<li>The name of the batch the sample was acquired in</li>
<li>The name of the channel the sample was acquired in</li>
</ul>
<p>Any additional information about the samples will be stored in the <code>colData</code>.</p>
<p>We provide an example of such a data frame. It was formatted from the annotation table provided in the SCoPE2 article. See <code><a href="../reference/sampleAnnotation.html">?sampleAnnotation</a></code> for more information about the table content.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"sampleAnnotation"</span><span class="op">)</span>
<span class="va">sampleAnnotation</span>
<span class="co">#&gt;                              Set Channel SampleType lcbatch sortday digest</span>
<span class="co">#&gt; 1          190222S_LCA9_X_FP94BM     RI1    Carrier    LCA9      s8      N</span>
<span class="co">#&gt; 2          190222S_LCA9_X_FP94BM     RI2  Reference    LCA9      s8      N</span>
<span class="co">#&gt; 3          190222S_LCA9_X_FP94BM     RI3     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 4          190222S_LCA9_X_FP94BM     RI4   Monocyte    LCA9      s8      N</span>
<span class="co">#&gt; 5          190222S_LCA9_X_FP94BM     RI5      Blank    LCA9      s8      N</span>
<span class="co">#&gt; 6          190222S_LCA9_X_FP94BM     RI6   Monocyte    LCA9      s8      N</span>
<span class="co">#&gt; 7          190222S_LCA9_X_FP94BM     RI7 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 8          190222S_LCA9_X_FP94BM     RI8 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 9          190222S_LCA9_X_FP94BM     RI9 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 10         190222S_LCA9_X_FP94BM    RI10 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 11         190222S_LCA9_X_FP94BM    RI11 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 12         190222S_LCA9_X_FP94BM    RI12     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 13         190222S_LCA9_X_FP94BM    RI13     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 14         190222S_LCA9_X_FP94BM    RI14     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 15         190222S_LCA9_X_FP94BM    RI15     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 16         190222S_LCA9_X_FP94BM    RI16     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 17        190321S_LCA10_X_FP97AG     RI1    Carrier   LCA10      s8      Q</span>
<span class="co">#&gt; 18        190321S_LCA10_X_FP97AG     RI2  Reference   LCA10      s8      Q</span>
<span class="co">#&gt; 19        190321S_LCA10_X_FP97AG     RI3     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 20        190321S_LCA10_X_FP97AG     RI4 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 21        190321S_LCA10_X_FP97AG     RI5   Monocyte   LCA10      s8      Q</span>
<span class="co">#&gt; 22        190321S_LCA10_X_FP97AG     RI6 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 23        190321S_LCA10_X_FP97AG     RI7 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 24        190321S_LCA10_X_FP97AG     RI8 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 25        190321S_LCA10_X_FP97AG     RI9 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 26        190321S_LCA10_X_FP97AG    RI10 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 27        190321S_LCA10_X_FP97AG    RI11 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 28        190321S_LCA10_X_FP97AG    RI12     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 29        190321S_LCA10_X_FP97AG    RI13     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 30        190321S_LCA10_X_FP97AG    RI14     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 31        190321S_LCA10_X_FP97AG    RI15     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 32        190321S_LCA10_X_FP97AG    RI16     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 33  190914S_LCB3_X_16plex_Set_21     RI1    Carrier    LCB3      s9      R</span>
<span class="co">#&gt; 34  190914S_LCB3_X_16plex_Set_21     RI2  Reference    LCB3      s9      R</span>
<span class="co">#&gt; 35  190914S_LCB3_X_16plex_Set_21     RI3     Unused    LCB3      s9      R</span>
<span class="co">#&gt; 36  190914S_LCB3_X_16plex_Set_21     RI4     Unused    LCB3      s9      R</span>
<span class="co">#&gt; 37  190914S_LCB3_X_16plex_Set_21     RI5 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 38  190914S_LCB3_X_16plex_Set_21     RI6 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 39  190914S_LCB3_X_16plex_Set_21     RI7      Blank    LCB3      s9      R</span>
<span class="co">#&gt; 40  190914S_LCB3_X_16plex_Set_21     RI8   Monocyte    LCB3      s9      R</span>
<span class="co">#&gt; 41  190914S_LCB3_X_16plex_Set_21     RI9 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 42  190914S_LCB3_X_16plex_Set_21    RI10   Monocyte    LCB3      s9      R</span>
<span class="co">#&gt; 43  190914S_LCB3_X_16plex_Set_21    RI11      Blank    LCB3      s9      R</span>
<span class="co">#&gt; 44  190914S_LCB3_X_16plex_Set_21    RI12 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 45  190914S_LCB3_X_16plex_Set_21    RI13 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 46  190914S_LCB3_X_16plex_Set_21    RI14 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 47  190914S_LCB3_X_16plex_Set_21    RI15 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 48  190914S_LCB3_X_16plex_Set_21    RI16 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 49 190321S_LCA10_X_FP97_blank_01     RI1      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 50 190321S_LCA10_X_FP97_blank_01     RI2      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 51 190321S_LCA10_X_FP97_blank_01     RI3      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 52 190321S_LCA10_X_FP97_blank_01     RI4      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 53 190321S_LCA10_X_FP97_blank_01     RI5      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 54 190321S_LCA10_X_FP97_blank_01     RI6      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 55 190321S_LCA10_X_FP97_blank_01     RI7      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 56 190321S_LCA10_X_FP97_blank_01     RI8      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 57 190321S_LCA10_X_FP97_blank_01     RI9      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 58 190321S_LCA10_X_FP97_blank_01    RI10      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 59 190321S_LCA10_X_FP97_blank_01    RI11      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 60 190321S_LCA10_X_FP97_blank_01    RI12      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 61 190321S_LCA10_X_FP97_blank_01    RI13      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 62 190321S_LCA10_X_FP97_blank_01    RI14      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 63 190321S_LCA10_X_FP97_blank_01    RI15      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 64 190321S_LCA10_X_FP97_blank_01    RI16      Blank   LCA10      s8   &lt;NA&gt;</span></code></pre></div>
<p>The two tables are supplied to the <code>readSCP</code> function.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/readSCP.html">readSCP</a></span><span class="op">(</span>featureData <span class="op">=</span> <span class="va">mqScpData</span>,
               colData <span class="op">=</span> <span class="va">sampleAnnotation</span>,
               channelCol <span class="op">=</span> <span class="st">"Channel"</span>,
               batchCol <span class="op">=</span> <span class="st">"Set"</span><span class="op">)</span>
<span class="co">#&gt; Loading data as a 'SingleCellExperiment' object</span>
<span class="co">#&gt; Splitting data based on 'Set'</span>
<span class="co">#&gt; Formatting sample metadata (colData)</span>
<span class="co">#&gt; Formatting data as a 'QFeatures' object</span></code></pre></div>
<p>As indicated by the output on the console, <code>readSCP</code> proceeds as follows:</p>
<ol style="list-style-type: decimal">
<li><p>If <code>featureData</code> is the path to a CSV file, it reads the file using <code>read.csv</code>. The table is converted to a <code>SingleCellExperiment</code> object. <code>readSCP</code> needs to know in which field(s) the quantitative data is stored. Those field name(s) is/are provided by the <code>channelCol</code> field in the <code>metaData</code> table. So in this example, the column names holding the quantitative data in <code>mqScpData</code> are stored in the column named <code>Channel</code> in <code>sampleAnnotation</code>.</p></li>
<li><p>The <code>SingleCellExperiment</code> object is then split according to batch. The split is performed depending on the <code>batchCol</code> field in <code>featureData</code>, in this case the data will be split according to the <code>Set</code> column in <code>mqScpData</code>.</p></li>
<li><p>The sample metadata is generated from the supplied <code>colData</code>. Note that in order for <code>readSCP</code> to correctly match the feature data with the metadata, <code>colData</code> must contain the same <code>batchCol</code> field with batch names.</p></li>
<li><p>Finally, the split feature data and the sample metadata are stored in a single <code>QFeatures</code> object.</p></li>
</ol>
<p>Here is a compact overview of the data:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 4 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 290 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97_blank_01: SingleCellExperiment with 109 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 375 rows and 16 columns </span>
<span class="co">#&gt;  [4] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 323 rows and 16 columns</span></code></pre></div>
<p>We can see that the <code>scp</code> object we created is a <code>QFeatures</code> object containing 4 assays. Each assay has an associated name, this is the batch name that was used for splitting. We can also see that each assay is a <code>SingleCellExperiment</code> object. The rows represent the peptide to spectrum matches (PSMs), the number vary depending on the batch. Finally, all three assays contains 16 columns that correspond to the 16 TMT channels recorded during the 4 MS runs.</p>
<div id="special-case-empty-columns" class="section level2">
<h2 class="hasAnchor">
<a href="#special-case-empty-columns" class="anchor"></a>Special case: empty columns</h2>
<p>The SCoPE2 data we provide as an example contains runs that were acquired with two TMT protocols. The 3 first assays were acquired using the TMT-11 protocol and the last assay was acquired using a TMT-16 protocol. When exporting the table, the authors combined the data in a single table, were missing channels in the TMT-11 data are filled with <code>NA</code>. This is essential when working in table format, but since <code>scp</code> keeps the runs separated we can allow for different number of channels per run. <code>readSCP</code> can automatically detect and remove columns that contain only <code>NA</code>s, by supplying the argument <code>removeEmptyCols = TRUE</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/readSCP.html">readSCP</a></span><span class="op">(</span>featureData <span class="op">=</span> <span class="va">mqScpData</span>,
               colData <span class="op">=</span> <span class="va">sampleAnnotation</span>,
               channelCol <span class="op">=</span> <span class="st">"Channel"</span>,
               batchCol <span class="op">=</span> <span class="st">"Set"</span>,
               removeEmptyCols <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; Loading data as a 'SingleCellExperiment' object</span>
<span class="co">#&gt; Splitting data based on 'Set'</span>
<span class="co">#&gt; Formatting sample metadata (colData)</span>
<span class="co">#&gt; Formatting data as a 'QFeatures' object</span>
<span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 4 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 290 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97_blank_01: SingleCellExperiment with 109 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 375 rows and 11 columns </span>
<span class="co">#&gt;  [4] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 323 rows and 16 columns</span></code></pre></div>
<p>See here that the 3 first assays contain 11 columns that correspond to the TMT-11 labels and the last assay contains 16 columns that correspond to the TMT-16 labels.</p>
</div>
</div>
<div id="clean-missing-data" class="section level1">
<h1 class="hasAnchor">
<a href="#clean-missing-data" class="anchor"></a>Clean missing data</h1>
<p>All single-cell data contain many zeros. The zeros can be biological zeros or technical zeros and differentiating between the two types is not a trivial task. To avoid artefacts in downstream steps, we replace the zeros by the missing value <code>NA</code>. The <code>zeroIsNA</code> function takes the <code>QFeatures</code> object and the name(s) or index/indices of the assay(s) to clean and automatically replaces any zero in the selected quantitative data by <code>NA</code>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">zeroIsNA</span><span class="op">(</span><span class="va">scp</span>, i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span></code></pre></div>
</div>
<div id="filter-psms" class="section level1">
<h1 class="hasAnchor">
<a href="#filter-psms" class="anchor"></a>Filter PSMs</h1>
<p>A common steps in SCP is to filter out low-confidence PSMs. Each PSM assay contains feature meta-information that are stored in the <code>rowData</code> of the assays. The <code>QFeatures</code> package allows to quickly filter the rows of an assay by using these information. The available variables in the <code>rowData</code> are listed below for each assay.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">rowDataNames</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>
<span class="co">#&gt; CharacterList of length 4</span>
<span class="co">#&gt; [["190222S_LCA9_X_FP94BM"]] uid Sequence Length ... residual participated</span>
<span class="co">#&gt; [["190321S_LCA10_X_FP97_blank_01"]] uid Sequence ... residual participated</span>
<span class="co">#&gt; [["190321S_LCA10_X_FP97AG"]] uid Sequence Length ... residual participated</span>
<span class="co">#&gt; [["190914S_LCB3_X_16plex_Set_21"]] uid Sequence ... residual participated</span></code></pre></div>
<div id="filter-features-based-on-feature-metadata" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-features-based-on-feature-metadata" class="anchor"></a>Filter features based on feature metadata</h2>
<p>Below are some examples of criteria that are used to identify low-confidence. The information is readily available since this was computed by MaxQuant:</p>
<ul>
<li>Remove PSMs that are matched to contaminants</li>
<li>Remove PSMs that are matched to the decoy database</li>
<li>Keep PSMs that exhibit a high PIF (parental ion fraction), indicative of the purity of a spectrum</li>
</ul>
<p>We can perform this filtering using the <code>filterFeatures</code> function from <code>QFeatures</code>. <code>filterFeatures</code> automatically accesses the feature metadata and selects the rows that meet the provided condition(s). For instance, <code>Reverse != "+"</code> keeps the rows for which the <code>Reverse</code> variable in the <code>rowData</code> is not <code>"+"</code> (<em>i.e.</em> the PSM is not matched to the decoy database).</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="va">Reverse</span> <span class="op">!=</span> <span class="st">"+"</span> <span class="op">&amp;</span>
                          <span class="va">Potential.contaminant</span> <span class="op">!=</span> <span class="st">"+"</span> <span class="op">&amp;</span>
                          <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">PIF</span><span class="op">)</span> <span class="op">&amp;</span> <span class="va">PIF</span> <span class="op">&gt;</span> <span class="fl">0.8</span><span class="op">)</span></code></pre></div>
</div>
<div id="filter-assays-based-on-detected-features" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-assays-based-on-detected-features" class="anchor"></a>Filter assays based on detected features</h2>
<p>To avoid proceeding with failed runs, another interesting filter is to remove assays with too few features. If a batch contains less than, for example, 150 features we can then suspect something wrong happened in that batch and it should be removed. Using <code>dims</code>, we can query the dimensions (hence the number of features and the number of samples) of all assays contained in the dataset.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">dims</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>
<span class="co">#&gt;      190222S_LCA9_X_FP94BM 190321S_LCA10_X_FP97_blank_01 190321S_LCA10_X_FP97AG</span>
<span class="co">#&gt; [1,]                   240                            60                    271</span>
<span class="co">#&gt; [2,]                    11                            11                     11</span>
<span class="co">#&gt;      190914S_LCB3_X_16plex_Set_21</span>
<span class="co">#&gt; [1,]                          180</span>
<span class="co">#&gt; [2,]                           16</span></code></pre></div>
<p>Actually, a <code>QFeatures</code> object can be seen as a three-order array: <span class="math inline">\(features \times samples \times assay\)</span>. Hence, <code>QFeatures</code> supports three-order subsetting <code>x[rows, columns, assays]</code>. We first select the assays that have sufficient PSMs (the number of rows is greater than 150), and then subset the <code>scp</code> object for the assays that meet the criterion.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">keepAssay</span> <span class="op">&lt;-</span> <span class="fu">dims</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">&gt;</span> <span class="fl">150</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, , <span class="va">keepAssay</span><span class="op">]</span>
<span class="co">#&gt; Warning: 'experiments' dropped; see 'metadata'</span>
<span class="co">#&gt; harmonizing input:</span>
<span class="co">#&gt;   removing 11 sampleMap rows not in names(experiments)</span>
<span class="co">#&gt;   removing 11 colData rownames not in sampleMap 'primary'</span>
<span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 3 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 240 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 271 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 180 rows and 16 columns</span></code></pre></div>
<p>Notice the <code>190321S_LCA10_X_FP97_blank_01</code> sample was removed because it did not contain sufficient features, as expected from a blank run. This could also have been the case for failed runs.</p>
</div>
<div id="filter-features-based-on-scp-metrics" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-features-based-on-scp-metrics" class="anchor"></a>Filter features based on SCP metrics</h2>
<p>Another type of filtering is specific to SCP. In the SCoPE2 analysis, the authors suggest a filters based on the sample to carrier ratio (SCR), that is the reporter ion intensity of a single-cell sample divided by the reporter ion intensity of the carrier channel (200 cells) from the same batch. It is expected that the carrier intensities are much higher than the single-cell intensities.</p>
<p>The SCR can be computed using the <code>computeSCR</code> function from <code>scp</code>. The function must be told which channels are the samples that must be divided and which channel contains the carrier. This information is provided in the sample metadata and is accessed using the <code>colData</code>, under the <code>SampleType</code> field.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="fu">colData</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">[</span>, <span class="st">"SampleType"</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      Blank    Carrier Macrophage   Monocyte  Reference     Unused </span>
<span class="co">#&gt;          3          3         20          5          3          4</span></code></pre></div>
<p>In this dataset, <code>SampleType</code> gives the type of sample that is present in each TMT channel. The SCoPE2 protocole includes 5 types of samples:</p>
<ul>
<li>The carrier channels (<code>Carrier</code>) contain 200 cell equivalents and are meant to boost the peptide identification rate.</li>
<li>The normalization channels (<code>Reference</code>) contain 5 cell equivalents and are used to partially correct for between-run variation.</li>
<li>The unused channels (<code>Unused</code>) are channels that are left empty due to isotopic cross-contamination by the carrier channel.</li>
<li>The blank channels (<code>Blank</code>) contain samples that do not contain any cell but are processed as single-cell samples.</li>
<li>The single-cell sample channels contain the single-cell samples of interest, that are macrophage (<code>Macrophage</code>) or monocyte (<code>Monocyte</code>).</li>
</ul>
<p>The <code>computeSCR</code> function expects the following input:</p>
<ul>
<li>The <code>QFeatures</code> dataset</li>
<li>The assay name(s) or index/indices for which the SCR should be computed</li>
<li>The sample metadata variable pointing to the channel annotation</li>
<li>A string pattern (following regular expression syntax) that uniquely identifies the carrier channel in each batch</li>
<li>A string pattern (following regular expression syntax) that identifies the samples to divide</li>
</ul>
<p>The function creates a new field in the <code>rowData</code> of the assays. We store the computed SCR in the <code>rowData</code> and call it <code>MeanSCR</code>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/computeSCR.html">computeSCR</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                  colDataCol <span class="op">=</span> <span class="st">"SampleType"</span>,
                  carrierPattern <span class="op">=</span> <span class="st">"Carrier"</span>,
                  samplePattern <span class="op">=</span> <span class="st">"Macrophage|Monocyte"</span>,
                  rowDataName <span class="op">=</span> <span class="st">"MeanSCR"</span><span class="op">)</span></code></pre></div>
<p>Before applying the filter, we plot the distribution of the average SCR. We can extract the <code>MeanSCR</code> variable from the <code>rowData</code> of several assays using the <code>rowDataToDF</code>. It takes the <code>rowData</code> field(s) of interest and returns a <code>DataFrame</code> table.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/rowDataToDF.html">rowDataToDF</a></span><span class="op">(</span>i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                vars <span class="op">=</span> <span class="st">"MeanSCR"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">MeanSCR</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">200</span>, <span class="fl">0.1</span><span class="op">)</span>,
               lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_log10</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/plot_SCR-1.png" width="700"></p>
<p>The expected ratio between single cells and the carrier is 1/200 (dashed line). We can see that the distribution mode is slightly shifted towards higher ratios with a mode around 0.01. However, there are a few PSMs that stand out of the distribution and have a much higher signal than expected, indicating something wrong happened during the quantification of those PSMs. We therefore filter out PSMs with an average SCR higher than 0.1 (solide line). This is again easily performed using the <code>filterFeatures</code> functions.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">MeanSCR</span><span class="op">)</span> <span class="op">&amp;</span>
                          <span class="va">MeanSCR</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span></code></pre></div>
</div>
<div id="filter-features-to-control-for-fdr" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-features-to-control-for-fdr" class="anchor"></a>Filter features to control for FDR</h2>
<p>Finally, we might also want to control for false discovery rate (FDR). MaxQuant already computes posterior error probabilities (PEP), but filtering on PEPs is too conservative (<span class="citation">Käll et al. (2008)</span>) so we provide the <code>pep2qvalue</code> function to convert PEPs to q-values that are directly related to FDR. We here compute the q-values from the PEP (<code>dart_PEP</code>) across all 3 assays. <code>dart_PEP</code> contains the PEP values that have been updated using the DART-ID algorithm (<span class="citation">Chen, Franks, and Slavov (2019)</span>). The function will store the results in the <code>rowData</code>, we here asked to name the new column <code>qvalue_PSMs</code>.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pep2qvalue.html">pep2qvalue</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                  PEP <span class="op">=</span> <span class="st">"dart_PEP"</span>,
                  rowDataName <span class="op">=</span> <span class="st">"qvalue_PSMs"</span><span class="op">)</span></code></pre></div>
<p>We also allow to compute q-values at peptide or protein level rather than PSM. In this case, you need to supply the <code>groupBy</code> argument. Suppose we want to compute the q-values at protein level, we can fetch the protein information stored under <code>protein</code> in the <code>rowData</code>. This time, we store the q-values in a new field called <code>qvalue_proteins</code>.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pep2qvalue.html">pep2qvalue</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                  PEP <span class="op">=</span> <span class="st">"dart_PEP"</span>,
                  groupBy <span class="op">=</span> <span class="st">"protein"</span>,
                  rowDataName <span class="op">=</span> <span class="st">"qvalue_proteins"</span><span class="op">)</span></code></pre></div>
<p>We can now filter the PSM to control, let’s say, the protein FDR at 1%. This can be performed using <code>filterFeatures</code> because the q-values were stored in the <code>rowData</code>.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="va">qvalue_proteins</span> <span class="op">&lt;</span> <span class="fl">0.01</span><span class="op">)</span></code></pre></div>
</div>
</div>
<div id="process-the-psm-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-psm-data" class="anchor"></a>Process the PSM data</h1>
<div id="relative-reporter-ion-intensity" class="section level2">
<h2 class="hasAnchor">
<a href="#relative-reporter-ion-intensity" class="anchor"></a>Relative reporter ion intensity</h2>
<p>In order to partialy correct for between-run variation, SCoPE2 suggests computing relative reporter ion intensities. This means that intensities measured for single-cells are divided by the reference channel containing 5-cell equivalents. We use the <code>divideByReference</code> function that divides channels of interest by the reference channel. Similarly to <code>computeSCR</code>, we can point to the samples and the reference columns in each assay using the annotation contained in the <code>colData</code>.</p>
<p>We here divide all columns (using the regular expression wildcard <code>.</code>) by the reference channel (<code>Reference</code>).</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/divideByReference.html">divideByReference</a></span><span class="op">(</span><span class="va">scp</span>,
                         i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                         colDataCol <span class="op">=</span> <span class="st">"SampleType"</span>,
                         samplePattern <span class="op">=</span> <span class="st">"."</span>,
                         refPattern <span class="op">=</span> <span class="st">"Reference"</span><span class="op">)</span></code></pre></div>
</div>
</div>
<div id="aggregate-psm-data-to-peptide-data" class="section level1">
<h1 class="hasAnchor">
<a href="#aggregate-psm-data-to-peptide-data" class="anchor"></a>Aggregate PSM data to peptide data</h1>
<p>Now that the PSM assays are processed, we can aggregate them to peptides. This is performed using the <code>aggregateFeaturesOverAssays</code> function. For each assay, the function aggregates several PSMs into a unique peptide. This is best illustrated by the figure below.</p>
<div class="figure" style="text-align: center">
<img src="figures/feature_aggregation.png" alt="Conceptual illustration of feature aggregation." width="100%"><p class="caption">
Conceptual illustration of feature aggregation.
</p>
</div>
<p>Remember there currently are three assays containing the PSM data.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 3 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns</span></code></pre></div>
<p>The PSMs are aggregated over the <code>fcol</code> feature variable, here peptides. We also need to supply an aggregating function that will tell how to combine the quantitative data of the PSMs to aggregate. We here aggregate the PSM data using the median value per sample thanks to the <code>matrixStats:colMedians</code> function. Other functions can be used and we refer to <code>?aggregateFeatures</code> for more information about available aggregation functions. The <code>aggregateFeaturesOverAssays</code> function will create a new assay for each aggregated assay. We name the aggregated assays using the original names and appending <code>peptides_</code> at the start.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/aggregateFeaturesOverAssays.html">aggregateFeaturesOverAssays</a></span><span class="op">(</span><span class="va">scp</span>,
                                   i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                                   fcol <span class="op">=</span> <span class="st">"peptide"</span>,
                                   name <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"peptides_"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span>,
                                   fun <span class="op">=</span> <span class="fu">matrixStats</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<p>Notice that 3 new assays were created in the <code>scp</code> object. Those new assays contain the aggregated features while the three first assays are unchanged. This allows to keep track of the data processing.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 6 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 211 rows and 11 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns</span></code></pre></div>
<p>Under the hood, the <code>QFeatures</code> architecture preserves the relationship between the aggregated assays. See <code>?AssayLinks</code> for more information on relationships between assays.</p>
</div>
<div id="join-the-scope2-sets-in-one-assay" class="section level1">
<h1 class="hasAnchor">
<a href="#join-the-scope2-sets-in-one-assay" class="anchor"></a>Join the SCoPE2 sets in one assay</h1>
<p>Up to now, we kept the data belonging to each MS run in separate assays. We now combine all batches into a single assay. This is done using the <code>joinAssays</code> function from the <code>QFeatures</code> package. Note that we now use the aggregated assays, so assay 4 to 6.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">joinAssays</span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fl">4</span><span class="op">:</span><span class="fl">6</span>,
                  name <span class="op">=</span> <span class="st">"peptides"</span><span class="op">)</span>
<span class="co">#&gt; Warning: 'experiments' dropped; see 'metadata'</span>
<span class="co">#&gt; harmonizing input:</span>
<span class="co">#&gt;   removing 38 sampleMap rows not in names(experiments)</span></code></pre></div>
<p>In this case, one new assay is created in the <code>scp</code> object that combines the data from assay 4 to 6. The samples are always distinct so the number of column in the new assay (here <span class="math inline">\(48\)</span>) will always equals the sum of the columns in the assays to join (here <span class="math inline">\(16 + 16 + 16\)</span>). The feature in the joined assay might contain less features than the sum of the rows of the assays to join since common features between assays are joined in a single row.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 7 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 211 rows and 11 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns </span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 369 rows and 38 columns</span></code></pre></div>
</div>
<div id="filter-single-cells" class="section level1">
<h1 class="hasAnchor">
<a href="#filter-single-cells" class="anchor"></a>Filter single-cells</h1>
<p>Another common step in single-cell data analysis pipelines is to remove low-quality cells. After subsetting for the samples of interest, we will use 2 metrics: the median relative intensities per cell and the median coefficient of variation (CV) per cell.</p>
<div id="filter-samples-of-interest" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-samples-of-interest" class="anchor"></a>Filter samples of interest</h2>
<p>We can subset the cells of interest, that is the blank samples (<code>sc_0</code>), the macrophages (<code>sc_m0</code>) and the monocytes (<code>sc_u</code>). This can easily be done by taking advantage of the <code>colData</code> and the subsetting operators. Recall that <code>QFeatures</code> objects support three-order subsetting, <code>x[rows, columns, assays]</code>, where columns are the samples of interest.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 7 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 11 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 211 rows and 11 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 11 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 16 columns </span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 369 rows and 38 columns</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, <span class="va">scp</span><span class="op">$</span><span class="va">SampleType</span> <span class="op">%in%</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Blank"</span>, <span class="st">"Macrophage"</span>, <span class="st">"Monocyte"</span><span class="op">)</span>, <span class="op">]</span></code></pre></div>
<p>The subsetting removes unwanted samples from all assays. The filtered data set contains the same number of assays with the same number of features, but the number of columns (hence sampled) decreased.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 7 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 8 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 8 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 12 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 211 rows and 8 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 8 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 12 columns </span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 369 rows and 28 columns</span></code></pre></div>
</div>
<div id="filter-based-on-the-median-relative-intensity" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-based-on-the-median-relative-intensity" class="anchor"></a>Filter based on the median relative intensity</h2>
<p>We compute the median relative reporter ion intensity for each cell separately and apply a filter based on this statistic. This procedure recalls that of library size filtering commonly performed in scRNA-Seq data analysis, where the library size is the sum of the counts in each single cell. We will store the median intensity in the <code>colData</code>. The medians are computed for every sample from the quantitative data using the <code>apply</code> function. The data matrix can be extracted from a <code>SingleCellExperiment</code> using the <code>assay</code> function. Setting <code>MARGIN = 2</code> means that we compute the median by column.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span><span class="op">[[</span><span class="st">"peptides"</span><span class="op">]</span><span class="op">]</span> <span class="op">%&gt;%</span>
    <span class="va">assay</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span>MARGIN <span class="op">=</span> <span class="fl">2</span>, 
          FUN <span class="op">=</span> <span class="va">median</span>, 
          na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">-&gt;</span>
    <span class="va">medians</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">medians</span><span class="op">)</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI4 190222S_LCA9_X_FP94BM_RI5 190222S_LCA9_X_FP94BM_RI6 </span>
<span class="co">#&gt;                 0.8799056                 0.5134779                 0.8390115 </span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI7 190222S_LCA9_X_FP94BM_RI8 190222S_LCA9_X_FP94BM_RI9 </span>
<span class="co">#&gt;                 0.4410601                 1.2305046                 1.0139141</span></code></pre></div>
<p>The computed medians are then inserted in the <code>colData</code>.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">colData</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">medians</span><span class="op">)</span>, <span class="st">"MedianRI"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">medians</span></code></pre></div>
<p>Looking at the distribution of the median per cell can highlight low-quality cells.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">%&gt;%</span>
    <span class="va">colData</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">MedianRI</span>, 
        y <span class="op">=</span> <span class="va">SampleType</span>,
        fill <span class="op">=</span> <span class="va">SampleType</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_boxplot.html">geom_boxplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_log10</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/plot_medianRI-1.png" width="700"></p>
<p>The blanks samples should not contain any peptide information and are therefore used to assess the amount of background signal. The graph above confirms that the signal measured in single-cells (macrophages and monocytes) is above the background signal, hence no filtering is needed. Would it not be the case, the same procedure as in the previous section can be used for selecting the cells that have an associated median RI lower that a defined threshold.</p>
</div>
<div id="filter-based-on-the-median-cv" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-based-on-the-median-cv" class="anchor"></a>Filter based on the median CV</h2>
<p>The median CV measures the consistency of quantification for a group of peptides that belong to a protein. We remove cells that exhibit high median CV over the different proteins. We compute the median CV per cell using the <code>computeMedianCV</code> function from the <code>scp</code> package. The function takes the <code>peptides</code> assay and computes the CV for each protein in each cell. To perform this, we must supply the name of the <code>rowData</code> field that contains the protein information through the <code>groupBy</code> argument. We also only want to compute CVs if we have at least 5 peptides per protein. Finally, we also perform a normalization and divide the columns by the median. The computed median CVs are automatically stored in the <code>colData</code> under the name that is supplied, here <code>MedianCV</code>.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/medianCVperCell.html">medianCVperCell</a></span><span class="op">(</span><span class="va">scp</span>,
                       i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                       groupBy <span class="op">=</span> <span class="st">"protein"</span>,
                       nobs <span class="op">=</span> <span class="fl">5</span>, 
                       norm <span class="op">=</span> <span class="st">"div.median"</span>,
                       na.rm <span class="op">=</span> <span class="cn">TRUE</span>,
                       colDataName <span class="op">=</span> <span class="st">"MedianCV"</span><span class="op">)</span></code></pre></div>
<p>The computed CVs are stored in the <code>colData</code> of the <code>peptides</code> assay and holds the median CV per cell computed using at least 5 observations (peptides). The main interest of computing the median CV per cell is to filter cells with reliable quantification. The blank samples are not expected to have reliable quantifications and hence can be used to estimate an empirical null distribution of the CV. This distribution helps defining a threshold that filters out single-cells that contain noisy quantification.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">%&gt;%</span>
    <span class="fu">getWithColData</span><span class="op">(</span><span class="st">"peptides"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">colData</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">MedianCV</span>,
               fill <span class="op">=</span> <span class="va">SampleType</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_boxplot.html">geom_boxplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fl">0.65</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/plot_medianCV-1.png" width="700"></p>
<p>We can see that the protein quantification for single-cells are much more consistent than for blank samples. Based on the distribution of the blanks, we decide to keep the cells that have a median CV lower than 0.65. Note this example is inaccurate because the null distribution is based on only 3 blank samples, but more sets could lead to a better estimation of the CV null distribution.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">scp</span><span class="op">$</span><span class="va">MedianCV</span><span class="op">)</span> <span class="op">&amp;</span> <span class="va">scp</span><span class="op">$</span><span class="va">MedianCV</span> <span class="op">&lt;</span> <span class="fl">0.65</span>, <span class="op">]</span></code></pre></div>
<p>We can now remove the blank samples since all QC metrics are now computed.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, <span class="va">scp</span><span class="op">$</span><span class="va">SampleType</span> <span class="op">!=</span> <span class="st">"Blank"</span>, <span class="op">]</span></code></pre></div>
</div>
</div>
<div id="process-the-peptide-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-peptide-data" class="anchor"></a>Process the peptide data</h1>
<p>In this vignette, the peptide data are further processed before aggregation to proteins. The steps are: normalization, filter peptides based on missing data and log-transformation.</p>
<div id="normalization" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization" class="anchor"></a>Normalization</h2>
<p>The columns (samples) of the peptide data are first normalized by dividing the relative intensities by the median relative intensities. Then, the rows (peptides) are normalized by dividing the relative intensities by the mean relative intensities. The normalized data is stored in a separate assay. This normalization procedure is suggested in the SCoPE2 analysis and is applied using the <code>sweep</code> method. Beside the dataset and the assay to normalize, the method expects a <code>MARGIN</code>, that is either row-wise (<code>1</code>) or column-wise (<code>2</code>) transformation, the <code>FUN</code> function to apply and <code>STATS</code>, a vector of values to apply. More conventional normalization procedure can be found in <code><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">?QFeatures::normalize</a></code>.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Divide columns by median</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span><span class="op">(</span><span class="va">scp</span>, 
             i <span class="op">=</span> <span class="st">"peptides"</span>,
             MARGIN <span class="op">=</span> <span class="fl">2</span>,
             FUN <span class="op">=</span> <span class="st">"/"</span>,
             STATS <span class="op">=</span> <span class="fu">colMedians</span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"peptides"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
             name <span class="op">=</span> <span class="st">"peptides_norm_col"</span><span class="op">)</span>
<span class="co">## Divide rows by mean</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span><span class="op">(</span><span class="va">scp</span>,
             i <span class="op">=</span> <span class="st">"peptides_norm_col"</span>,
             MARGIN <span class="op">=</span> <span class="fl">1</span>,
             FUN <span class="op">=</span> <span class="st">"/"</span>,
             STATS <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"peptides_norm_col"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>,  na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
             name <span class="op">=</span> <span class="st">"peptides_norm"</span><span class="op">)</span></code></pre></div>
<p>Notice each call to <code>sweep</code> created a new assay.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 9 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 6 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 7 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 4 columns </span>
<span class="co">#&gt;  ...</span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 369 rows and 17 columns </span>
<span class="co">#&gt;  [8] peptides_norm_col: SingleCellExperiment with 369 rows and 17 columns </span>
<span class="co">#&gt;  [9] peptides_norm: SingleCellExperiment with 369 rows and 17 columns</span></code></pre></div>
<p>Let’s point out</p>
</div>
<div id="remove-peptides-with-high-missing-rate" class="section level2">
<h2 class="hasAnchor">
<a href="#remove-peptides-with-high-missing-rate" class="anchor"></a>Remove peptides with high missing rate</h2>
<p>Peptides that contain many missing values are not informative. Therefore, another common procedure is to remove higly missing data. In this example, we remove peptides with more than 99 % missing data. This is done using the <code>filterNA</code> function from <code>QFeatures</code>.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">filterNA</span><span class="op">(</span><span class="va">scp</span>,
                i <span class="op">=</span> <span class="st">"peptides_norm"</span>,
                pNA <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></code></pre></div>
</div>
<div id="log-transformation" class="section level2">
<h2 class="hasAnchor">
<a href="#log-transformation" class="anchor"></a>Log-transformation</h2>
<p>In this vignette, we perform log2-transformation using the <code>logTransform</code> method from <code>QFeatures</code>. Other log-transformation can be applied by changing the <code>base</code> argument.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">logTransform</span><span class="op">(</span><span class="va">scp</span>,
                    base <span class="op">=</span> <span class="fl">2</span>,
                    i <span class="op">=</span> <span class="st">"peptides_norm"</span>,
                    name <span class="op">=</span> <span class="st">"peptides_log"</span><span class="op">)</span></code></pre></div>
<p>Similarly to <code>sweep</code>, <code>logTransform</code> creates a new assay in <code>scp</code>.</p>
</div>
</div>
<div id="aggregate-peptide-data-to-protein-data" class="section level1">
<h1 class="hasAnchor">
<a href="#aggregate-peptide-data-to-protein-data" class="anchor"></a>Aggregate peptide data to protein data</h1>
<p>Similarly to aggregating PSM data to peptide data, we can aggregate peptide data to protein data using the <code>aggregateFeatures</code> function.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">aggregateFeatures</span><span class="op">(</span><span class="va">scp</span>,
                         i <span class="op">=</span> <span class="st">"peptides_log"</span>,
                         name <span class="op">=</span> <span class="st">"proteins"</span>,
                         fcol <span class="op">=</span> <span class="st">"protein"</span>,
                         fun <span class="op">=</span> <span class="fu">matrixStats</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; Your quantitative and row data contain missing values. Please read the</span>
<span class="co">#&gt; relevant section(s) in the aggregateFeatures manual page regarding the</span>
<span class="co">#&gt; effects of missing values on data aggregation.</span></code></pre></div>
<p>The only difference between <code>aggregateFeatures</code> and <code>aggregateFeaturesOverAssays</code> is that the second function can aggregate several assay at once whereas the former only takes one assay to aggregate. Hence, only a single assay, <code>proteins</code>, was created in the <code>scp</code> object.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 11 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 213 rows and 6 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 243 rows and 7 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 163 rows and 4 columns </span>
<span class="co">#&gt;  ...</span>
<span class="co">#&gt;  [9] peptides_norm: SingleCellExperiment with 357 rows and 17 columns </span>
<span class="co">#&gt;  [10] peptides_log: SingleCellExperiment with 357 rows and 17 columns </span>
<span class="co">#&gt;  [11] proteins: SingleCellExperiment with 89 rows and 17 columns</span></code></pre></div>
<p>After the second aggregation, the <code>proteins</code> assay in this example contains quantitative information for 89 proteins in 15 single-cells.</p>
</div>
<div id="process-the-protein-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-protein-data" class="anchor"></a>Process the protein data</h1>
<p>The protein data is further processed in three steps: normalization, imputation (using the KNN algorithm) and batch correction (using the <code>ComBat</code> algorithm).</p>
<div id="normalization-1" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-1" class="anchor"></a>Normalization</h2>
<p>Normalization is performed similarly to peptide normalization. We use the same functions, but since the data were log-transformed at the peptide level, we subtract by the statistic (median or mean) instead of dividing.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">%&gt;%</span>
    <span class="co">## Center columns with median</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span><span class="op">(</span>i <span class="op">=</span> <span class="st">"proteins"</span>,
          MARGIN <span class="op">=</span> <span class="fl">2</span>,
          FUN <span class="op">=</span> <span class="st">"-"</span>,
          STATS <span class="op">=</span> <span class="fu">colMedians</span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>,
                             na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
          name <span class="op">=</span> <span class="st">"proteins_norm_col"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="co">## Center rows with mean</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span><span class="op">(</span>i <span class="op">=</span> <span class="st">"proteins_norm_col"</span>,
          MARGIN <span class="op">=</span> <span class="fl">1</span>,
          FUN <span class="op">=</span> <span class="st">"-"</span>,
          STATS <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">.</span><span class="op">[[</span><span class="st">"proteins_norm_col"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>,
                           na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
          name <span class="op">=</span> <span class="st">"proteins_norm"</span><span class="op">)</span> <span class="op">-&gt;</span>
    <span class="va">scp</span></code></pre></div>
</div>
<div id="imputation" class="section level2">
<h2 class="hasAnchor">
<a href="#imputation" class="anchor"></a>Imputation</h2>
<p>The protein data contains a lot of missing values.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_norm"</span><span class="op">]</span><span class="op">]</span> <span class="op">%&gt;%</span>
    <span class="va">assay</span> <span class="op">%&gt;%</span>
    <span class="va">is.na</span> <span class="op">%&gt;%</span>
    <span class="va">mean</span>
<span class="co">#&gt; [1] 0.2326504</span></code></pre></div>
<p>The average missingness in the <code>proteins</code> assay is around 25 %. Including more samples and hence more batches can increase the missingness up to 70 % as seen for the complete SCoPE2 dataset (<span class="citation">Specht et al. (2021)</span>). Whether imputation is beneficial or deleterious for the data will not be discussed in this vignette. But taking those missing value into account is essential to avoid artefacts in downstream analyses. The data imputation is performed using the K nearest neighbors algorithm, with k = 3. This is available from the <code>impute</code> mehtod. More details about the arguments can be found in <code><a href="https://rdrr.io/pkg/impute/man/impute.knn.html">?impute::impute.knn</a></code>.</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">impute</span><span class="op">(</span><span class="va">scp</span>,
              i <span class="op">=</span> <span class="st">"proteins_norm"</span>,
              method <span class="op">=</span> <span class="st">"knn"</span>,
              k <span class="op">=</span> <span class="fl">3</span>, rowmax <span class="op">=</span> <span class="fl">1</span>, colmax<span class="op">=</span> <span class="fl">1</span>,
              maxp <span class="op">=</span> <span class="cn">Inf</span>, rng.seed <span class="op">=</span> <span class="fl">1234</span><span class="op">)</span>
<span class="co">#&gt; Loading required namespace: impute</span></code></pre></div>
<p>Note that after imputation, no value are missing.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_norm"</span><span class="op">]</span><span class="op">]</span> <span class="op">%&gt;%</span>
    <span class="va">assay</span> <span class="op">%&gt;%</span>
    <span class="va">is.na</span> <span class="op">%&gt;%</span>
    <span class="va">mean</span>
<span class="co">#&gt; [1] 0</span></code></pre></div>
</div>
<div id="batch-correction" class="section level2">
<h2 class="hasAnchor">
<a href="#batch-correction" class="anchor"></a>Batch correction</h2>
<p>A very important step for processing SCP data is to correct for batch effects. Batch effects are caused by technical variation occuring during different MS runs. Since only a small number of single-cells can be acquired at once, batch effects are unavoidable.</p>
<p>The <code>ComBat</code> function from the <code>sva</code> package can be used to perform batch correction as it is performed in the SCoPE2 analysis. We do not claim that <code>ComBat</code> is the best algorithm for batch correcting SCP data and other batch correcting methods could be used using the same procedure.</p>
<p>We first extract the assay to process.</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu">getWithColData</span><span class="op">(</span><span class="va">scp</span>, <span class="st">"proteins_norm"</span><span class="op">)</span>
<span class="co">#&gt; Warning: 'experiments' dropped; see 'metadata'</span>
<span class="co">#&gt; harmonizing input:</span>
<span class="co">#&gt;   removing 136 sampleMap rows not in names(experiments)</span></code></pre></div>
<p>Next, we need to provide a design matrix and the batch annotation to <code>Combat</code>. The design matrix allows to protect variables of interest, in our case <code>SampleType</code>.</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">batch</span> <span class="op">&lt;-</span> <span class="fu">colData</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span><span class="op">$</span><span class="va">Set</span>
<span class="va">model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html">model.matrix</a></span><span class="op">(</span><span class="op">~</span> <span class="va">SampleType</span>, data <span class="op">=</span> <span class="fu">colData</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>We then load and call <code>ComBat</code> and overwrite the data matrix. Recall the data matrix can be accessed using the <code>assay</code> function.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">sva</span><span class="op">)</span>
<span class="fu">assay</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sva/man/ComBat.html">ComBat</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="fu">assay</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span>,
                     batch <span class="op">=</span> <span class="va">batch</span>,
                     mod <span class="op">=</span> <span class="va">model</span><span class="op">)</span></code></pre></div>
<p>Finally, we add the batch corrected assay to the <code>QFeatures</code> object and create the feature links.</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">addAssay</span><span class="op">(</span><span class="va">scp</span>,
         y <span class="op">=</span> <span class="va">sce</span>,
         name <span class="op">=</span> <span class="st">"proteins_batchC"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu">addAssayLinkOneToOne</span><span class="op">(</span>from <span class="op">=</span> <span class="st">"proteins_norm"</span>,
                         to <span class="op">=</span> <span class="st">"proteins_batchC"</span><span class="op">)</span> <span class="op">-&gt;</span>
    <span class="va">scp</span></code></pre></div>
</div>
</div>
<div id="dimension-reduction" class="section level1">
<h1 class="hasAnchor">
<a href="#dimension-reduction" class="anchor"></a>Dimension reduction</h1>
<p>Because each assay contains <code>SingelCellExperiment</code> objects, we can easily apply methods developed in the scRNA-Seq field. A useful package for dimension reduction on single-cell data is the <code>scater</code>.</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://bioconductor.org/packages/scater/">scater</a></span><span class="op">)</span>
<span class="co">#&gt; Loading required package: SingleCellExperiment</span></code></pre></div>
<p>This package provides streamline functions to computes various dimension reduction such as PCA, UMAP, t-SNE, NMF, MDS, ….</p>
<div id="pca" class="section level2">
<h2 class="hasAnchor">
<a href="#pca" class="anchor"></a>PCA</h2>
<p>PCA can be computed using the <code>runPCA</code> method. It returns a <code>SingleCellExperiment</code> object for which the dimension reduction results are stored in the <code>reducedDim</code> slot.</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scater/man/runPCA.html">runPCA</a></span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span>,
                                   ncomponents <span class="op">=</span> <span class="fl">5</span>,
                                   ntop <span class="op">=</span> <span class="cn">Inf</span>,
                                   scale <span class="op">=</span> <span class="cn">TRUE</span>,
                                   exprs_values <span class="op">=</span> <span class="fl">1</span>,
                                   name <span class="op">=</span> <span class="st">"PCA"</span><span class="op">)</span></code></pre></div>
<p>The computed PCA can be displayed using the <code>plotReducedDim</code> function. The <code>dimred</code> arguments should give the name of the dimension reduction results to plot, here we called it <code>PCA</code>. The samples are colored by type of sample.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/scater/man/plotReducedDim.html">plotReducedDim</a></span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span>,
               dimred <span class="op">=</span> <span class="st">"PCA"</span>,
               colour_by <span class="op">=</span> <span class="st">"SampleType"</span>,
               point_alpha <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/plot_PCA-1.png" width="700"></p>
<p>This is a minimalistic example with only a few plotted cells, but the original SCoPE2 dataset contained more than thousand cells.</p>
</div>
<div id="umap" class="section level2">
<h2 class="hasAnchor">
<a href="#umap" class="anchor"></a>UMAP</h2>
<p>Similarly to PCA, we can compute a UMAP using the <code>runUMAP</code> method. Note however that the UMAP implementation requires a initialization, usually provided by PCA. The previous PCA results are used automatically when supplying <code>dimred = "PCA"</code> (<code>PCA</code> is the name of the dimension reduction result that we supplied in the previous section).</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scater/man/runUMAP.html">runUMAP</a></span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span>,
                                    ncomponents <span class="op">=</span> <span class="fl">2</span>,
                                    ntop <span class="op">=</span> <span class="cn">Inf</span>,
                                    scale <span class="op">=</span> <span class="cn">TRUE</span>,
                                    exprs_values <span class="op">=</span> <span class="fl">1</span>,
                                    n_neighbors <span class="op">=</span> <span class="fl">3</span>,
                                    dimred <span class="op">=</span> <span class="st">"PCA"</span>,
                                    name <span class="op">=</span> <span class="st">"UMAP"</span><span class="op">)</span></code></pre></div>
<p>The computed UMAP can be displayed using the <code>plotReducedDim</code> function. The <code>dimred</code> arguments gives the name of the dimension reduction results to plot, here we called it <code>UMAP</code>. The samples are colored by type of sample.</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/scater/man/plotReducedDim.html">plotReducedDim</a></span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC"</span><span class="op">]</span><span class="op">]</span>,
               dimred <span class="op">=</span> <span class="st">"UMAP"</span>,
               colour_by <span class="op">=</span> <span class="st">"SampleType"</span>,
               point_alpha <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/plot_UMAP-1.png" width="700"></p>
<p>The UMAP plot is a very interesting plot for large datasets. A UMAP on this small example dataset is not useful but is shown for illustration.</p>
</div>
</div>
<div id="monitoring-data-processing" class="section level1">
<h1 class="hasAnchor">
<a href="#monitoring-data-processing" class="anchor"></a>Monitoring data processing</h1>
<p>The <code>QFeatures</code> plot shows the quantitative data for a features at the different expression levels. For instance, suppose we are interested in the protein <em>LMNA</em> (protein ID is <code>P02545</code>). A useful QC is to monitor the data processing at the PSM, peptide and protein level. This can easily be done thanks to the <code>QFeatures</code> framework. Using the <code>subsetByFeature</code>, we can extract the protein of interest and its related features in the other assays. The data is formated to a long format table that can easily be plugged in the <code>ggplot2</code> visualization tool.</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">%&gt;%</span>
    <span class="co">## Get the features related to LMNA (P02545)</span>
    <span class="fu">subsetByFeature</span><span class="op">(</span><span class="st">"P02545"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="co">## Format the `QFeatures` to a long format table</span>
    <span class="fu">longFormat</span><span class="op">(</span>colDataCols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Set"</span>, <span class="st">"SampleType"</span>, <span class="st">"Channel"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="co">## This is used to preserve ordering of the samples and assays in ggplot2</span>
    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>assay <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span><span class="op">(</span><span class="va">assay</span>, levels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span>,
           Channel <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">sub</a></span><span class="op">(</span><span class="st">"RI"</span>, <span class="st">"TMT-"</span>, <span class="va">Channel</span><span class="op">)</span>,
           Channel <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span><span class="op">(</span><span class="va">Channel</span>, levels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">Channel</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="co">## Start plotting</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">Channel</span>, y <span class="op">=</span> <span class="va">value</span>, group <span class="op">=</span> <span class="va">rowname</span>, col <span class="op">=</span> <span class="va">SampleType</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="co">## Plot every assay in a separate facet</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html">facet_wrap</a></span><span class="op">(</span>facets <span class="op">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/vars.html">vars</a></span><span class="op">(</span><span class="va">assay</span><span class="op">)</span>, scales <span class="op">=</span> <span class="st">"free_y"</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span>
    <span class="co">## Annotate plot</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">xlab</a></span><span class="op">(</span><span class="st">"Channels"</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">ylab</a></span><span class="op">(</span><span class="st">"Intensity (arbitrary units)"</span><span class="op">)</span> <span class="op">+</span>
    <span class="co">## Improve plot aspect</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html">theme</a></span><span class="op">(</span>axis.text.x <span class="op">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html">element_text</a></span><span class="op">(</span>angle <span class="op">=</span> <span class="fl">90</span><span class="op">)</span>,
          strip.text <span class="op">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html">element_text</a></span><span class="op">(</span>hjust <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>,
          legend.position <span class="op">=</span> <span class="st">"bottom"</span><span class="op">)</span></code></pre></div>
<p><img src="scp_files/figure-html/monitor_plot-1.png" width="100%"></p>
<p>This graph helps to keep track of the data processing and highlights anomalies in the data. For instance, we can see that no data were recorded for 5 channels (TMT-12 to 16). Those channels contain either macrophages or monocytes (from the experimental design) and are expected to contain information. Thanks to this diagnostic plot, we reported the issue to Specht and colleagues and this led to version 3 of the SCoPE2 dataset.</p>
</div>
<div id="session-information" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session information</h1>
<pre><code>R Under development (unstable) (2021-02-11 r79990)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.2 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] scater_1.19.9                SingleCellExperiment_1.13.10
 [3] sva_3.39.0                   BiocParallel_1.25.4         
 [5] genefilter_1.73.1            mgcv_1.8-33                 
 [7] nlme_3.1-152                 dplyr_1.0.4                 
 [9] magrittr_2.0.1               ggplot2_3.3.3               
[11] scp_1.1.4                    QFeatures_1.1.1             
[13] MultiAssayExperiment_1.17.11 SummarizedExperiment_1.21.1 
[15] Biobase_2.51.0               GenomicRanges_1.43.3        
[17] GenomeInfoDb_1.27.6          IRanges_2.25.6              
[19] S4Vectors_0.29.7             BiocGenerics_0.37.1         
[21] MatrixGenerics_1.3.1         matrixStats_0.58.0          
[23] BiocStyle_2.19.1            

loaded via a namespace (and not attached):
 [1] ggbeeswarm_0.6.0          colorspace_2.0-0         
 [3] ellipsis_0.3.1            rprojroot_2.0.2          
 [5] scuttle_1.1.15            XVector_0.31.1           
 [7] BiocNeighbors_1.9.4       fs_1.5.0                 
 [9] farver_2.0.3              bit64_4.0.5              
[11] RSpectra_0.16-0           AnnotationDbi_1.53.1     
[13] splines_4.1.0             sparseMatrixStats_1.3.6  
[15] cachem_1.0.4              impute_1.65.0            
[17] knitr_1.31                annotate_1.69.0          
[19] png_0.1-7                 uwot_0.1.10              
[21] BiocManager_1.30.10       compiler_4.1.0           
[23] httr_1.4.2                assertthat_0.2.1         
[25] Matrix_1.3-2              fastmap_1.1.0            
[27] lazyeval_0.2.2            limma_3.47.7             
[29] BiocSingular_1.7.2        htmltools_0.5.1.1        
[31] tools_4.1.0               rsvd_1.0.3               
[33] gtable_0.3.0              glue_1.4.2               
[35] GenomeInfoDbData_1.2.4    Rcpp_1.0.6               
[37] pkgdown_1.6.1.9000        vctrs_0.3.6              
[39] Biostrings_2.59.2         DelayedMatrixStats_1.13.5
[41] xfun_0.21                 stringr_1.4.0            
[43] beachmat_2.7.6            lifecycle_1.0.0          
[45] irlba_2.3.3               XML_3.99-0.5             
[47] edgeR_3.33.1              zlibbioc_1.37.0          
[49] MASS_7.3-53.1             scales_1.1.1             
[51] ragg_1.1.0                ProtGenerics_1.23.7      
[53] AnnotationFilter_1.15.0   yaml_2.2.1               
[55] gridExtra_2.3             memoise_2.0.0            
[57] stringi_1.5.3             RSQLite_2.2.3            
[59] highr_0.8                 desc_1.2.0               
[61] ScaledMatrix_0.99.2       rlang_0.4.10             
[63] pkgconfig_2.0.3           systemfonts_1.0.1        
[65] bitops_1.0-6              evaluate_0.14            
[67] lattice_0.20-41           purrr_0.3.4              
[69] labeling_0.4.2            bit_4.0.4                
[71] tidyselect_1.1.0          bookdown_0.21            
[73] R6_2.5.0                  generics_0.1.0           
[75] DelayedArray_0.17.7       DBI_1.1.1                
[77] pillar_1.4.7              withr_2.4.1              
[79] MsCoreUtils_1.3.2         survival_3.2-7           
[81] KEGGREST_1.31.1           RCurl_1.98-1.2           
[83] tibble_3.0.6              crayon_1.4.1             
[85] rmarkdown_2.6             viridis_0.5.1            
[87] locfit_1.5-9.4            grid_4.1.0               
[89] FNN_1.1.3                 blob_1.2.1               
[91] digest_0.6.27             xtable_1.8-4             
[93] textshaping_0.3.0         munsell_0.5.0            
[95] viridisLite_0.3.0         beeswarm_0.2.3           
[97] vipor_0.4.5              </code></pre>
</div>
<div id="reference" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#reference" class="anchor"></a>Reference</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Amezquita2019-bf" class="csl-entry">
Amezquita, Robert A, Aaron T L Lun, Etienne Becht, Vince J Carey, Lindsay N Carpp, Ludwig Geistlinger, Federico Martini, et al. 2019. <span>“Orchestrating Single-Cell Analysis with Bioconductor.”</span> <em>Nat. Methods</em>, December, 1–9.
</div>
<div id="ref-Chen2019-uc" class="csl-entry">
Chen, Albert Tian, Alexander Franks, and Nikolai Slavov. 2019. <span>“<span>DART-ID</span> Increases Single-Cell Proteome Coverage.”</span> <em>PLoS Comput. Biol.</em> 15 (7): e1007082.
</div>
<div id="ref-Gatto2020-ry" class="csl-entry">
Gatto, Laurent. 2020. <span>“<span>QFeatures</span>: Quantitative Features for Mass Spectrometry Data.”</span>
</div>
<div id="ref-Kall2008-hb" class="csl-entry">
Käll, Lukas, John D Storey, Michael J MacCoss, and William Stafford Noble. 2008. <span>“Posterior Error Probabilities and False Discovery Rates: Two Sides of the Same Coin.”</span> <em>J. Proteome Res.</em> 7 (1): 40–44.
</div>
<div id="ref-Specht2021-jm" class="csl-entry">
Specht, Harrison, Edward Emmott, Aleksandra A Petelski, R Gray Huffman, David H Perlman, Marco Serra, Peter Kharchenko, Antonius Koller, and Nikolai Slavov. 2021. <span>“Single-Cell Proteomic and Transcriptomic Analysis of Macrophage Heterogeneity Using <span>SCoPE2</span>.”</span> <em>Genome Biol.</em> 22 (1): 50.
</div>
<div id="ref-Tyanova2016-yj" class="csl-entry">
Tyanova, Stefka, Tikira Temu, and Juergen Cox. 2016. <span>“The <span>MaxQuant</span> Computational Platform for Mass Spectrometry-Based Shotgun Proteomics.”</span> <em>Nat. Protoc.</em> 11 (12): 2301–19.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Christophe Vanderaa, Laurent Gatto.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
