<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Single Cell Proteomics data processing and analysis. • scp</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Single Cell Proteomics data processing and analysis.">
<meta property="og:description" content="scp">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">scp</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.99.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/scp.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/UCLouvain-CBIO/scp/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="scp_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Single Cell Proteomics data processing and analysis.</h1>
                        <h4 class="author">Laurent Gatto</h4>
                                    <h4 class="author">Christophe Vanderaa</h4>
                        
            <h4 class="date">9 September 2020</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/UCLouvain-CBIO/scp/blob/master/vignettes/scp.Rmd"><code>vignettes/scp.Rmd</code></a></small>
      <div class="hidden name"><code>scp.Rmd</code></div>

    </div>

    
    
<div id="the-scp-package" class="section level1">
<h1 class="hasAnchor">
<a href="#the-scp-package" class="anchor"></a>The <code>scp</code> package</h1>
<p>The <code>scp</code> package is used to process and analyse mass spectrometry-based single cell proteomics (SCP) data. It relies on the <a href="https://rformassspectrometry.github.io/QFeatures/"><code>QFeatures</code></a> (<span class="citation">Gatto (2020)</span>) package to manage and process <a href="http://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html"><code>SingleCellExperiment</code></a> (<span class="citation">Lun and Risso (2020)</span>) objects.</p>
<div class="figure" style="text-align: center">
<img src="figures/SCP_framework.png" alt="`scp` relies on `SingleCellExperiment` and `QFeatures` objects." width="100%"><p class="caption">
<code>scp</code> relies on <code>SingleCellExperiment</code> and <code>QFeatures</code> objects.
</p>
</div>
<p>This vignette will guide you through the common steps of mass spectrometry-based single-cell proteomics data analysis. To start, we load the <code>scp</code> package.</p>
<div class="sourceCode" id="cb1"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st"><a href="https://UCLouvain-CBIO.github.io/scp">"scp"</a></span>)</pre></div>
<p>We also load <code>ggplot2</code>, <code>magrittr</code> and <code>dplyr</code> for convenient data manipulation and plotting.</p>
<div class="sourceCode" id="cb2"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st"><a href="http://ggplot2.tidyverse.org">"ggplot2"</a></span>)
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"magrittr"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st"><a href="https://dplyr.tidyverse.org">"dplyr"</a></span>)</pre></div>
</div>
<div id="read-in-scp-data" class="section level1">
<h1 class="hasAnchor">
<a href="#read-in-scp-data" class="anchor"></a>Read in SCP data</h1>
<p>The workflow starts with reading in the tabular quantification data generated by, for example, MaxQuant (<span class="citation">Cox and Mann (2008)</span>). We created a small example data by subsetting the MaxQuant table provided in the SCoPE2 preprint (<span class="citation">Specht et al. (2019)</span>). The <code>mqScpData</code> table is a typical example of what you would get after reading in a CSV file using <code>read.csv</code> or <code>read.table</code>. See <code><a href="../reference/mqScpData.html">?mqScpData</a></code> for more information about the table content.</p>
<div class="sourceCode" id="cb3"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="st">"mqScpData"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="kw">mqScpData</span>)
<span class="co">#&gt; [1] 1197  139</span>
<span class="kw">mqScpData</span>[<span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]
<span class="co">#&gt;                Sequence Length Modifications      Modified.sequence</span>
<span class="co">#&gt; 1  AADPPAENSSAPEAEQGGAE     20    Unmodified _AADPPAENSSAPEAEQGGAE_</span>
<span class="co">#&gt; 2            AANLNSIIHR     10    Unmodified           _AANLNSIIHR_</span>
<span class="co">#&gt; 3              AARATGLR      8    Unmodified             _AARATGLR_</span>
<span class="co">#&gt; 4             AAVLLEQER      9    Unmodified            _AAVLLEQER_</span>
<span class="co">#&gt; 5           AAYEAELGDAR     11    Unmodified          _AAYEAELGDAR_</span>
<span class="co">#&gt; 6               AFEAVDK      7    Unmodified              _AFEAVDK_</span>
<span class="co">#&gt; 7               AGESWDK      7    Unmodified              _AGESWDK_</span>
<span class="co">#&gt; 8              AGLYGLPR      8    Unmodified             _AGLYGLPR_</span>
<span class="co">#&gt; 9           AGQAVDDFIEK     11    Unmodified          _AGQAVDDFIEK_</span>
<span class="co">#&gt; 10          AGQAVDDFIEK     11    Unmodified          _AGQAVDDFIEK_</span>
<span class="co">#&gt;    Deamidation..N..Probabilities</span>
<span class="co">#&gt; 1                           &lt;NA&gt;</span>
<span class="co">#&gt; 2                           &lt;NA&gt;</span>
<span class="co">#&gt; 3                           &lt;NA&gt;</span>
<span class="co">#&gt; 4                           &lt;NA&gt;</span>
<span class="co">#&gt; 5                           &lt;NA&gt;</span>
<span class="co">#&gt; 6                           &lt;NA&gt;</span>
<span class="co">#&gt; 7                           &lt;NA&gt;</span>
<span class="co">#&gt; 8                           &lt;NA&gt;</span>
<span class="co">#&gt; 9                           &lt;NA&gt;</span>
<span class="co">#&gt; 10                          &lt;NA&gt;</span></pre></div>
<p>In order to convert this tabular data to a <code>scp</code>-compatible <code>QFeatures</code> object, we need to provide a <strong>metadata table</strong> where rows contain sample information and columns must contain at least:</p>
<ul>
<li>The name of the batch the sample was acquired in</li>
<li>The name of the channel the sample was acquired in</li>
</ul>
<p>Any additional information about the samples will be stored in the <code>colData</code>.</p>
<p>We provide an example of such a data frame. It was formatted from the annotation table provided in the SCoPE2 preprint. See <code><a href="../reference/sampleAnnotation.html">?sampleAnnotation</a></code> for more information about the table content.</p>
<div class="sourceCode" id="cb4"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="st">"sampleAnnotation"</span>)
<span class="kw">sampleAnnotation</span>
<span class="co">#&gt;                              Set Channel SampleType lcbatch sortday digest</span>
<span class="co">#&gt; 1          190222S_LCA9_X_FP94BM     RI1    Carrier    LCA9      s8      N</span>
<span class="co">#&gt; 2          190222S_LCA9_X_FP94BM     RI2  Reference    LCA9      s8      N</span>
<span class="co">#&gt; 3          190222S_LCA9_X_FP94BM     RI3     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 4          190222S_LCA9_X_FP94BM     RI4   Monocyte    LCA9      s8      N</span>
<span class="co">#&gt; 5          190222S_LCA9_X_FP94BM     RI5      Blank    LCA9      s8      N</span>
<span class="co">#&gt; 6          190222S_LCA9_X_FP94BM     RI6   Monocyte    LCA9      s8      N</span>
<span class="co">#&gt; 7          190222S_LCA9_X_FP94BM     RI7 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 8          190222S_LCA9_X_FP94BM     RI8 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 9          190222S_LCA9_X_FP94BM     RI9 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 10         190222S_LCA9_X_FP94BM    RI10 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 11         190222S_LCA9_X_FP94BM    RI11 Macrophage    LCA9      s8      N</span>
<span class="co">#&gt; 12         190222S_LCA9_X_FP94BM    RI12     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 13         190222S_LCA9_X_FP94BM    RI13     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 14         190222S_LCA9_X_FP94BM    RI14     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 15         190222S_LCA9_X_FP94BM    RI15     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 16         190222S_LCA9_X_FP94BM    RI16     Unused    LCA9      s8      N</span>
<span class="co">#&gt; 17        190321S_LCA10_X_FP97AG     RI1    Carrier   LCA10      s8      Q</span>
<span class="co">#&gt; 18        190321S_LCA10_X_FP97AG     RI2  Reference   LCA10      s8      Q</span>
<span class="co">#&gt; 19        190321S_LCA10_X_FP97AG     RI3     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 20        190321S_LCA10_X_FP97AG     RI4 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 21        190321S_LCA10_X_FP97AG     RI5   Monocyte   LCA10      s8      Q</span>
<span class="co">#&gt; 22        190321S_LCA10_X_FP97AG     RI6 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 23        190321S_LCA10_X_FP97AG     RI7 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 24        190321S_LCA10_X_FP97AG     RI8 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 25        190321S_LCA10_X_FP97AG     RI9 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 26        190321S_LCA10_X_FP97AG    RI10 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 27        190321S_LCA10_X_FP97AG    RI11 Macrophage   LCA10      s8      Q</span>
<span class="co">#&gt; 28        190321S_LCA10_X_FP97AG    RI12     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 29        190321S_LCA10_X_FP97AG    RI13     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 30        190321S_LCA10_X_FP97AG    RI14     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 31        190321S_LCA10_X_FP97AG    RI15     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 32        190321S_LCA10_X_FP97AG    RI16     Unused   LCA10      s8      Q</span>
<span class="co">#&gt; 33  190914S_LCB3_X_16plex_Set_21     RI1    Carrier    LCB3      s9      R</span>
<span class="co">#&gt; 34  190914S_LCB3_X_16plex_Set_21     RI2  Reference    LCB3      s9      R</span>
<span class="co">#&gt; 35  190914S_LCB3_X_16plex_Set_21     RI3     Unused    LCB3      s9      R</span>
<span class="co">#&gt; 36  190914S_LCB3_X_16plex_Set_21     RI4     Unused    LCB3      s9      R</span>
<span class="co">#&gt; 37  190914S_LCB3_X_16plex_Set_21     RI5 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 38  190914S_LCB3_X_16plex_Set_21     RI6 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 39  190914S_LCB3_X_16plex_Set_21     RI7      Blank    LCB3      s9      R</span>
<span class="co">#&gt; 40  190914S_LCB3_X_16plex_Set_21     RI8   Monocyte    LCB3      s9      R</span>
<span class="co">#&gt; 41  190914S_LCB3_X_16plex_Set_21     RI9 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 42  190914S_LCB3_X_16plex_Set_21    RI10   Monocyte    LCB3      s9      R</span>
<span class="co">#&gt; 43  190914S_LCB3_X_16plex_Set_21    RI11      Blank    LCB3      s9      R</span>
<span class="co">#&gt; 44  190914S_LCB3_X_16plex_Set_21    RI12 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 45  190914S_LCB3_X_16plex_Set_21    RI13 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 46  190914S_LCB3_X_16plex_Set_21    RI14 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 47  190914S_LCB3_X_16plex_Set_21    RI15 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 48  190914S_LCB3_X_16plex_Set_21    RI16 Macrophage    LCB3      s9      R</span>
<span class="co">#&gt; 49 190321S_LCA10_X_FP97_blank_01     RI1      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 50 190321S_LCA10_X_FP97_blank_01     RI2      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 51 190321S_LCA10_X_FP97_blank_01     RI3      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 52 190321S_LCA10_X_FP97_blank_01     RI4      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 53 190321S_LCA10_X_FP97_blank_01     RI5      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 54 190321S_LCA10_X_FP97_blank_01     RI6      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 55 190321S_LCA10_X_FP97_blank_01     RI7      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 56 190321S_LCA10_X_FP97_blank_01     RI8      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 57 190321S_LCA10_X_FP97_blank_01     RI9      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 58 190321S_LCA10_X_FP97_blank_01    RI10      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 59 190321S_LCA10_X_FP97_blank_01    RI11      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 60 190321S_LCA10_X_FP97_blank_01    RI12      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 61 190321S_LCA10_X_FP97_blank_01    RI13      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 62 190321S_LCA10_X_FP97_blank_01    RI14      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 63 190321S_LCA10_X_FP97_blank_01    RI15      Blank   LCA10      s8   &lt;NA&gt;</span>
<span class="co">#&gt; 64 190321S_LCA10_X_FP97_blank_01    RI16      Blank   LCA10      s8   &lt;NA&gt;</span></pre></div>
<p>The two tables are supplied to the <code>readSCP</code> function.</p>
<div class="sourceCode" id="cb5"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/readSCP.html">readSCP</a></span>(quantTable = <span class="kw">mqScpData</span>,
               metaTable = <span class="kw">sampleAnnotation</span>,
               channelCol = <span class="st">"Channel"</span>,
               batchCol = <span class="st">"Set"</span>)
<span class="co">#&gt; Loading data as a 'SingleCellExperiment' object</span>
<span class="co">#&gt; Splitting data based on 'Set'</span>
<span class="co">#&gt; Formating sample metadata (colData)</span>
<span class="co">#&gt; Formating data as a 'QFeatures' object</span></pre></div>
<p>As indicated by the output on the console, <code>readSCP</code> proceeds as follows:</p>
<ol style="list-style-type: decimal">
<li><p>If <code>quantTable</code> is the path to a CSV file, it reads the file using <code>read.csv</code>. The table is converted to a <code>SingleCellExperiment</code> object. <code>readSCP</code> needs to know in which field(s) the quantative data is stored. Those field name(s) is/are provided by the <code>channelCol</code> field in the <code>metaData</code> table. So in this example, the column names hodling the quantitative data in <code>mqScpData</code> are stored in the column named <code>Channel</code> in <code>sampleAnnotation</code>.</p></li>
<li><p>The <code>SingleCellExperiment</code> object is then split according to batch. The split is performed depending on the <code>batchCol</code> field in <code>quantTable</code>, in this case the data will be split according to the <code>Set</code> column in <code>mqScpData</code>.</p></li>
<li><p>The sample metadata is generated from the <code>metaTable</code>. Note that in order for <code>readSCP</code> to correctly match the feature data with the metadata, <code>metaTable</code> must also contain the <code>batchCol</code> field with batch names.</p></li>
<li><p>Finally, the split feature data and the sample metadata are stored in a single <code>QFeatures</code> object.</p></li>
</ol>
<p>Here is a compact overview of the data:</p>
<div class="sourceCode" id="cb6"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 4 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 334 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97_blank_01: SingleCellExperiment with 109 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 433 rows and 16 columns </span>
<span class="co">#&gt;  [4] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 321 rows and 16 columns</span></pre></div>
<p>We can see that the <code>scp</code> object we created is a <code>QFeatures</code> object containing 4 assays. Each assay has an associated name, this is the batch name that was used for splitting. We can also see that each assay is a <code>SingleCellExperiment</code> object. The rows represent the peptide to spectrum matches (PSMs), the number vary depending on the batch. Finally, all three assays contains 16 columns that correspond to the 16 TMT channels recorded during the 4 MS runs.</p>
</div>
<div id="clean-missing-data" class="section level1">
<h1 class="hasAnchor">
<a href="#clean-missing-data" class="anchor"></a>Clean missing data</h1>
<p>Single-cell (proteomics or transcriptomics) data contains many zeros. The zeros can be biological zeros or technical zeros and differentiating between the two types is very hard. To avoid artefacts in dowstream steps, we replace the zeros by the missing value <code>NA</code>. The <code>zeroIsNA</code> function takes the <code>QFeatures</code> object and the name(s) or index/indices of the assay(s) to clean and automatically replaces any zero in the selected quantitative data by <code>NA</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">zeroIsNA</span>(<span class="kw">scp</span>, i = <span class="fl">1</span><span class="op">:</span><span class="fl">4</span>)</pre></div>
</div>
<div id="filter-psms" class="section level1">
<h1 class="hasAnchor">
<a href="#filter-psms" class="anchor"></a>Filter PSMs</h1>
<p>A common steps in SCP is to filter out low-confidence PSMs. Each PSM assay contains feature meta-information that are stored in the assay’s <code>rowData</code>. The <code>QFeatures</code> package allows to quickly filter the rows of an assay by using these information. The available variables in the <code>rowData</code> are listed below for each assay.</p>
<div class="sourceCode" id="cb8"><pre class="downlit">
<span class="fu">rowDataNames</span>(<span class="kw">scp</span>)
<span class="co">#&gt; CharacterList of length 4</span>
<span class="co">#&gt; [["190222S_LCA9_X_FP94BM"]] Sequence Length ... participated peptide</span>
<span class="co">#&gt; [["190321S_LCA10_X_FP97_blank_01"]] Sequence Length ... participated peptide</span>
<span class="co">#&gt; [["190321S_LCA10_X_FP97AG"]] Sequence Length ... participated peptide</span>
<span class="co">#&gt; [["190914S_LCB3_X_16plex_Set_21"]] Sequence Length ... participated peptide</span></pre></div>
<div id="filter-features-based-on-feature-metadata" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-features-based-on-feature-metadata" class="anchor"></a>Filter features based on feature metadata</h2>
<p>Below are some examples of criteria that are used to identify low-confidence. The information is readily available since this was computed by MaxQuant:</p>
<ul>
<li>Remove PSMs that are matched to contaminants</li>
<li>Remove PSMs that are matched to the decoy database</li>
<li>Keep PSMs that exhibit a high PIF (parental ion fraction), indicative of the purity of a spectrum</li>
</ul>
<p>We can perform this filtering using the <a href="https://rformassspectrometry.github.io/QFeatures/reference/QFeatures-filtering.html"><code>filterFeatures</code> function</a>. <code>filterFeatures</code> automatically accesses the feature metadata and selects the rows that meet the provided condition(s). For instance, <code>Reverse != "+"</code> keeps the rows for which the <code>Reverse</code> variable in the <code>rowData</code> is not <code>"+"</code> (<em>i.e.</em> the PSM is not matched to the decoy database).</p>
<div class="sourceCode" id="cb9"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span>(<span class="kw">scp</span>,
                      <span class="op">~</span> <span class="kw">Reverse</span> != <span class="st">"+"</span> <span class="op">&amp;</span>
                        <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grepl</a></span>(<span class="st">"REV|CON"</span>, <span class="kw">protein</span>) <span class="op">&amp;</span>
                        <span class="kw">Potential.contaminant</span> != <span class="st">"+"</span> <span class="op">&amp;</span>
                        <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">PIF</span>) <span class="op">&amp;</span> <span class="kw">PIF</span> <span class="op">&gt;</span> <span class="fl">0.8</span>)</pre></div>
</div>
<div id="filter-assays-based-on-detected-features" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-assays-based-on-detected-features" class="anchor"></a>Filter assays based on detected features</h2>
<p>To avoid proceeding with failed runs, another interesting filter is to remove assays with too few features. If a batch contains less than, for example, 150 features we can then suspect something wrong happened in that batch and it should be removed. Using <code>dims</code>, we can query the dimensions (hence the number of features and the number of samples) of all assays contained in the dataset.</p>
<div class="sourceCode" id="cb10"><pre class="downlit">
<span class="fu">dims</span>(<span class="kw">scp</span>)
<span class="co">#&gt;      190222S_LCA9_X_FP94BM 190321S_LCA10_X_FP97_blank_01 190321S_LCA10_X_FP97AG</span>
<span class="co">#&gt; [1,]                   253                            57                    282</span>
<span class="co">#&gt; [2,]                    16                            16                     16</span>
<span class="co">#&gt;      190914S_LCB3_X_16plex_Set_21</span>
<span class="co">#&gt; [1,]                          183</span>
<span class="co">#&gt; [2,]                           16</span></pre></div>
<p>Actually, a <code>QFeatures</code> object can be seen as a three-order array: <span class="math inline">\(features \times samples \times assay\)</span>. Hence, <code>QFeatures</code> supports three-order subsetting <code>x[rows, columns, assays]</code>. We first select the assay that have sufficient PSMs (the number of rows is greater than 150), and then subset the <code>scp</code> object for the assays that meet the criterion.</p>
<div class="sourceCode" id="cb11"><pre class="downlit">
<span class="kw">keepAssay</span> <span class="op">&lt;-</span> <span class="fu">dims</span>(<span class="kw">scp</span>)[<span class="fl">1</span>, ] <span class="op">&gt;</span> <span class="fl">150</span>
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="kw">scp</span>[, , <span class="kw">keepAssay</span>]
<span class="co">#&gt; harmonizing input:</span>
<span class="co">#&gt;   removing 16 sampleMap rows not in names(experiments)</span>
<span class="co">#&gt;   removing 16 colData rownames not in sampleMap 'primary'</span>
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 3 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 253 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 282 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 183 rows and 16 columns</span></pre></div>
<p>Notice the <code>190321S_LCA10_X_FP97_blank_01</code> sample was removed because it did not contain sufficient features, as expected from a blank sample. This could also have been the case for failed runs.</p>
</div>
<div id="filter-features-based-on-scp-metrics" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-features-based-on-scp-metrics" class="anchor"></a>Filter features based on SCP metrics</h2>
<p>Another type of filtering is specific to SCP. In the SCoPE2 analysis, the authors suggest a filters based on the sample to carrier ratio (SCR), that is the reporter ion intensity of a single-cell sample divided by the reporter ion intensity of the carrier channel (200 cells) from the same batch. It is expected that the carrier intensities are much higher than the single-cell intensities.</p>
<p>The SCR can be computed using the <code>computeSCR</code> function from <code>scp</code>. The function must be told which channels are the samples that must be divided and which channel contains the carrier. This information is provided in the sample metadata and is accessed using the <code>colData</code>, under the <code>SampleType</code> field.</p>
<div class="sourceCode" id="cb12"><pre class="downlit">
<span class="fu">colData</span>(<span class="kw">scp</span>)[, <span class="st">"SampleType"</span>] <span class="op">%&gt;%</span>
  <span class="kw">table</span>
<span class="co">#&gt; .</span>
<span class="co">#&gt;      Blank    Carrier Macrophage   Monocyte  Reference     Unused </span>
<span class="co">#&gt;          3          3         20          5          3         14</span></pre></div>
<p>In this dataset, <code>SampleType</code> gives the type of sample that is present in each TMT channel. The SCoPE2 protocole includes 5 types of samples:</p>
<ul>
<li>The carrier channels (<code>Carrier</code>) contain 200 cell equivalents and are meant to boost the peptide identification rate.</li>
<li>The normalization channels (<code>Reference</code>) contain 5 cell equivalents and are used to partially correct for between-run variation.</li>
<li>The unused channels (<code>Unused</code>) are channels that are left empty due to isotopic cross-contamination by the carrier channel.</li>
<li>The blank channels (<code>Blank</code>) contain samples that do not contain any cell but are processed as single-cell samples.</li>
<li>The single-cell sample channels contain the single-cell samples of interest, that are macrophage (<code>Macrophage</code>) or monocyte (<code>Monocyte</code>).</li>
</ul>
<p>The <code>computeSCR</code> function expects the following input:</p>
<ul>
<li>The <code>QFeatures</code> dataset</li>
<li>The assay name(s) or index/indices for which the SCR should be computed</li>
<li>The sample metadata variable pointing to the channel annotation</li>
<li>A string pattern (following regular expression syntax) that uniquely identifies the carrier channel in each batch</li>
<li>A string pattern (following regular expression syntax) that identifies the samples to divide</li>
</ul>
<p>The function creates an field <code>.meanSCR</code> and stores it in the <code>rowData</code> of each assay.</p>
<div class="sourceCode" id="cb13"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/computeSCR.html">computeSCR</a></span>(<span class="kw">scp</span>,
                  i = <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                  colDataCol = <span class="st">"SampleType"</span>,
                  carrierPattern = <span class="st">"Carrier"</span>,
                  samplePattern = <span class="st">"Macrophage|Monocyte"</span>)</pre></div>
<p>Before applying the filter, we plot the distribution of the average SCR. We can extract the <code>.meanSCR</code> variable from the <code>rowData</code> of several assays using the <code>rowDataToDF</code>. It takes the <code>rowData</code> field(s) of interest and returns a <code>DataFrame</code> table.</p>
<div class="sourceCode" id="cb14"><pre class="downlit">
<span class="kw">scp</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="../reference/rowDataToDF.html">rowDataToDF</a></span>(i = <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
              vars = <span class="st">".meanSCR"</span>) <span class="op">%&gt;%</span>
  <span class="kw">data.frame</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(x = <span class="kw">.meanSCR</span>)) <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span>() <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span>(xintercept = <span class="fl">0.1</span>)</pre></div>
<p><img src="scp_files/figure-html/plot_SCR-1.png" width="700"></p>
<p>Most values are close to 0.02 as expected since the experimental ratio is 1/200. There are a few point that have higher signal than expected. We therefore filter out those points using a cutoff of 0.1 using again the <code>filterFeatures</code> functions.</p>
<div class="sourceCode" id="cb15"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span>(<span class="kw">scp</span>,
                      <span class="op">~</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">.meanSCR</span>) <span class="op">&amp;</span>
                        <span class="kw">.meanSCR</span> <span class="op">&lt;</span> <span class="fl">0.1</span>)</pre></div>
</div>
<div id="filter-out-psms-with-high-false-discovery-rate" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-out-psms-with-high-false-discovery-rate" class="anchor"></a>Filter out PSMs with high false discovery rate</h2>
<p>Finally, a last PSM filter criterion is the false discovery rate (FDR) for identification. Filtering on the PEP is too conservative (<span class="citation">Käll et al. (2008)</span>) so we provide the <code>computeFDR</code> function to convert PEPs to FDR. Beside the dataset and the assay(s) for which to compute the FDR, we also need to give the feature grouping variable, here the peptide sequence, and the variable containing the PEPs. Those are contained in the feature metadata.</p>
<div class="sourceCode" id="cb16"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/computeFDR.html">computeFDR</a></span>(<span class="kw">scp</span>,
                  i = <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                  groupCol = <span class="st">"peptide"</span>,
                  pepCol = <span class="st">"dart_PEP"</span>)</pre></div>
<p>Note that a new variable <code>.FDR</code> containing the computed FDRs is added to the <code>rowData</code>. We filter the PSMs that have an associated peptide FDR smaller than 1%.</p>
<div class="sourceCode" id="cb17"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">filterFeatures</span>(<span class="kw">scp</span>,
                      <span class="op">~</span> <span class="kw">.FDR</span> <span class="op">&lt;</span> <span class="fl">0.01</span>)</pre></div>
</div>
</div>
<div id="process-the-psm-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-psm-data" class="anchor"></a>Process the PSM data</h1>
<div id="relative-reporter-ion-intensity" class="section level2">
<h2 class="hasAnchor">
<a href="#relative-reporter-ion-intensity" class="anchor"></a>Relative reporter ion intensity</h2>
<p>In order to partialy correct for between-run variation, SCoPE2 suggests computing relative reporter ion intensities. This means that intensities measured for single-cells are divided by the reference channel containing 5-cell equivalents. We use the <code>divideByReference</code> function that divides channels of interest by the reference channel. Similarly to <code>computeSCR</code>, we can point to the samples and the reference columns in each assay using the annotation contained in the <code>colData</code>.</p>
<p>We here divide all columns (using the regular expression wildcard <code>.</code>) by the reference channel (<code>Reference</code>).</p>
<div class="sourceCode" id="cb18"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/divideByReference.html">divideByReference</a></span>(<span class="kw">scp</span>,
                         i = <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                         colDataCol = <span class="st">"SampleType"</span>,
                         samplePattern = <span class="st">"."</span>,
                         refPattern = <span class="st">"Reference"</span>)</pre></div>
</div>
</div>
<div id="aggregate-psm-data-to-peptide-data" class="section level1">
<h1 class="hasAnchor">
<a href="#aggregate-psm-data-to-peptide-data" class="anchor"></a>Aggregate PSM data to peptide data</h1>
<p>Now that the PSM assays are processed, we can aggregate them to peptides. This is performed using the <code>aggregateFeaturesOverAssays</code> function. For each assay, the function aggregates several PSMs into a unique peptide. This is best illustrated by the figure below.</p>
<div class="figure" style="text-align: center">
<img src="figures/feature_aggregation.png" alt="Conceptual illustration of feature aggregation." width="100%"><p class="caption">
Conceptual illustration of feature aggregation.
</p>
</div>
<p>Remember there currently are three assays containing the PSM data.</p>
<div class="sourceCode" id="cb19"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 3 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns</span></pre></div>
<p>The PSMs are aggregated over the <code>fcol</code> feature variable, here peptides. We also need to supply an aggregating function that will tell how to combine the quantitative data of the PSMs to aggregate. We here use the median value. We name the aggregated assays using the original names and appending <code>peptides_</code> at the start.</p>
<div class="sourceCode" id="cb20"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span><span class="fu"><a href="../reference/aggregateFeaturesOverAssays.html">aggregateFeaturesOverAssays</a></span>(<span class="kw">scp</span>,
                                  i = <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,
                                  fcol = <span class="st">"peptide"</span>,
                                  name = <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span>(<span class="st">"peptides_"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">scp</span>)),
                                  fun = <span class="kw">matrixStats</span>::<span class="kw"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>, na.rm = <span class="fl">TRUE</span>)</pre></div>
<p>Notice that 3 new assays were created in the <code>scp</code> object. Those new assays contain the aggregated features while the three first assays are unchanged. This allows to keep track of the data processing.</p>
<div class="sourceCode" id="cb21"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 6 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 214 rows and 16 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns</span></pre></div>
<p>Under the hood, the <code>QFeatures</code> architecture preserves the relationship between the aggregated assays. See <code>?AssayLinks</code> for more information on relationships between assays.</p>
</div>
<div id="join-the-scope2-sets-in-one-assay" class="section level1">
<h1 class="hasAnchor">
<a href="#join-the-scope2-sets-in-one-assay" class="anchor"></a>Join the SCoPE2 sets in one assay</h1>
<p>Up to now, we kept the data belonging to each MS run in separate assays. We now combine all batches into a single assay. This is done using the <code>joinAssays</code> function from the <code>QFeatures</code> package. Note that we now use the aggregated assays, so assay 4 to 6.</p>
<div class="sourceCode" id="cb22"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">joinAssays</span>(<span class="kw">scp</span>,
                  i = <span class="fl">4</span><span class="op">:</span><span class="fl">6</span>,
                  name = <span class="st">"peptides"</span>)
<span class="co">#&gt; harmonizing input:</span>
<span class="co">#&gt;   removing 48 sampleMap rows not in names(experiments)</span></pre></div>
<p>In this case, one new assay is created in the <code>scp</code> object that combines the data from assay 4 to 6. The samples are always distinct so the number of column in the new assay (here <span class="math inline">\(48\)</span>) will always equals the sum of the columns in the assays to join (here <span class="math inline">\(16 + 16 + 16\)</span>). The feature in the joined assay might contain less features than the sum of the rows of the assays to join since common features between assays are joined in a single row.</p>
<div class="sourceCode" id="cb23"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 7 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  [4] peptides_190222S_LCA9_X_FP94BM: SingleCellExperiment with 214 rows and 16 columns </span>
<span class="co">#&gt;  [5] peptides_190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 358 rows and 48 columns</span></pre></div>
</div>
<div id="filter-single-cells" class="section level1">
<h1 class="hasAnchor">
<a href="#filter-single-cells" class="anchor"></a>Filter single-cells</h1>
<p>Another common step in single-cell data analysis pipelines is to remove low-quality cells. After subseting for the samples of interest, we will use 2 metrics: the median relative intensities per cell and the median coefficient of variation (CV) per cell.</p>
<div id="filter-samples-of-interest" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-samples-of-interest" class="anchor"></a>Filter samples of interest</h2>
<p>We first subset the cells of interest, that is the blank samples (<code>sc_0</code>), the macrophages (<code>sc_m0</code>) and the monocytes (<code>sc_u</code>).</p>
<p>We extract the <code>SingleCellExperiment</code> assay with the joined peptides, subset the channels corresponding to blank, macrophage or monocytes and add it as a new assay in the <code>QFeatures</code> object. However, the sample annotation is contained in the <code>colData</code> of the <code>QFeatures</code> dataset, but we need to access it from the <code>SingeCellExperiment</code> object. Therefore, we provide the <code>transferColDataToAssay</code> to copy the sample metadata from the <code>QFeatures</code> to a target assay.</p>
<div class="sourceCode" id="cb24"><pre class="downlit">
<span class="fu">colData</span>(<span class="kw">scp</span>[[<span class="st">"peptides"</span>]])
<span class="co">#&gt; DataFrame with 48 rows and 0 columns</span>
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/transferColDataToAssay.html">transferColDataToAssay</a></span>(<span class="kw">scp</span>, <span class="st">"peptides"</span>)
<span class="fu">colData</span>(<span class="kw">scp</span>[[<span class="st">"peptides"</span>]])
<span class="co">#&gt; DataFrame with 48 rows and 6 columns</span>
<span class="co">#&gt;                                             Set     Channel  SampleType</span>
<span class="co">#&gt;                                     &lt;character&gt; &lt;character&gt; &lt;character&gt;</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI1         190222S_LC...         RI1     Carrier</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI2         190222S_LC...         RI2   Reference</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI3         190222S_LC...         RI3      Unused</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI4         190222S_LC...         RI4    Monocyte</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI5         190222S_LC...         RI5       Blank</span>
<span class="co">#&gt; ...                                         ...         ...         ...</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI12 190914S_LC...        RI12  Macrophage</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI13 190914S_LC...        RI13  Macrophage</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI14 190914S_LC...        RI14  Macrophage</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI15 190914S_LC...        RI15  Macrophage</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI16 190914S_LC...        RI16  Macrophage</span>
<span class="co">#&gt;                                       lcbatch     sortday      digest</span>
<span class="co">#&gt;                                   &lt;character&gt; &lt;character&gt; &lt;character&gt;</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI1                LCA9          s8           N</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI2                LCA9          s8           N</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI3                LCA9          s8           N</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI4                LCA9          s8           N</span>
<span class="co">#&gt; 190222S_LCA9_X_FP94BM_RI5                LCA9          s8           N</span>
<span class="co">#&gt; ...                                       ...         ...         ...</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI12        LCB3          s9           R</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI13        LCB3          s9           R</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI14        LCB3          s9           R</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI15        LCB3          s9           R</span>
<span class="co">#&gt; 190914S_LCB3_X_16plex_Set_21_RI16        LCB3          s9           R</span></pre></div>
<p>Once the metadata is transfered, we can subset the <code>SingleCellExperiment</code> assay.</p>
<div class="sourceCode" id="cb25"><pre class="downlit">
<span class="kw">sce</span> <span class="op">&lt;-</span> <span class="kw">scp</span>[[<span class="st">"peptides"</span>]]
<span class="kw">sce</span> <span class="op">&lt;-</span> <span class="kw">sce</span>[, <span class="kw">sce</span><span class="op">$</span><span class="kw">SampleType</span> <span class="op">%in%</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"Blank"</span>, <span class="st">"Macrophage"</span>, <span class="st">"Monocyte"</span>)]</pre></div>
<p>Then we add this assay back into the <code>QFeatures</code> object. This is done using the <code>addAssay</code> function. We also preserve the links between dfeatures using the <code>addAssayLinkOneToOne</code>. Since the features did not change (only the samples did), one-to-one links between features are added.</p>
<div class="sourceCode" id="cb26"><pre class="downlit">
<span class="kw">scp</span> <span class="op">%&gt;%</span>
  <span class="fu">addAssay</span>(y = <span class="kw">sce</span>,
           name = <span class="st">"peptides_filter1"</span>) <span class="op">%&gt;%</span>
  <span class="fu">addAssayLinkOneToOne</span>(from = <span class="st">"peptides"</span>,
                       to = <span class="st">"peptides_filter1"</span>) <span class="op">-&gt;</span>
  <span class="kw">scp</span></pre></div>
<p>Note the added assay <code>peptides_filter1</code> contains the same number of rows than its parent assay <code>peptides</code>, but less samples as 20 samples are not single-cells or blank samples bu rather unused, reference or carrier samples.</p>
<div class="sourceCode" id="cb27"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 8 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  ...</span>
<span class="co">#&gt;  [6] peptides_190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  [7] peptides: SingleCellExperiment with 358 rows and 48 columns </span>
<span class="co">#&gt;  [8] peptides_filter1: SingleCellExperiment with 358 rows and 28 columns</span></pre></div>
</div>
<div id="filter-based-on-the-median-relative-intensity" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-based-on-the-median-relative-intensity" class="anchor"></a>Filter based on the median relative intensity</h2>
<p>We compute the median relative reporter ion intensity for each cell separately and apply a filter based on this statistic. This procedure recalls that of library size filtering commonly performed in scRNA-Seq data analysis, where the library size is the sum of the counts in each single cell. We will store the median intensity in the <code>colData</code> of the <code>peptides_filter1</code> assay (so the <code>SingleCellExperiment</code> object) because this metric is specific to that assay. The medians are computed on the quantitative data using <code>colMedians</code> that requires a data matrix. The data matrix can be extracted from a <code>SingleCellExperiment</code> using the <code>assay</code> function.</p>
<div class="sourceCode" id="cb28"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]] <span class="op">%&gt;%</span>
  <span class="kw">assay</span> <span class="op">%&gt;%</span>
  <span class="kw">matrixStats</span>::<span class="fu"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>(na.rm = <span class="fl">TRUE</span>) <span class="op">-&gt;</span>
  <span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]]<span class="op">$</span><span class="kw">MedianRI</span></pre></div>
<p>Looking at the distribution of the median per cell can highlight low-quality cells.</p>
<div class="sourceCode" id="cb29"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]] <span class="op">%&gt;%</span>
  <span class="kw">colData</span> <span class="op">%&gt;%</span>
  <span class="kw">data.frame</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(x = <span class="kw">MedianRI</span>, fill = <span class="kw">SampleType</span>)) <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_boxplot.html">geom_boxplot</a></span>() <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_log10</a></span>()</pre></div>
<p><img src="scp_files/figure-html/plot_medianRI-1.png" width="700"></p>
<p>Here all values seems reasonable so no filtering is needed. If it were not the case, the same procedure as the previous section can be used for selecting the cells that have an associated median RI lower that a defined threshold.</p>
</div>
<div id="filter-based-on-the-median-cv" class="section level2">
<h2 class="hasAnchor">
<a href="#filter-based-on-the-median-cv" class="anchor"></a>Filter based on the median CV</h2>
<p>The median CV measures the consistency of quantification for a group of peptides that belong to a protein. We remove cells that exhibit high median CV over the different proteins. We compute the median CV per cell using the <code>computeMedianCV</code> function from the <code>scp</code> package. The function takes the <code>peptides_filter1</code> assay, protein and peptide information from the assay <code>rowData</code>, and the batch names in the <code>colData</code> of the <code>QFeatures</code> object. The peptide and batch information are required to perform normalization prior to the CV computation. Protein information is required since the CV are computed at the protein level. The computed median CVs are automatically stored in the <code>colData</code> of the <code>SingleCellExperiment</code> assay under the <code>.medianCV</code> field</p>
<div class="sourceCode" id="cb30"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/computeMedianCV.html">computeMedianCV</a></span>(<span class="kw">scp</span>,
                       i = <span class="st">"peptides_filter1"</span>,
                       proteinCol = <span class="st">"protein"</span>,
                       peptideCol = <span class="st">"peptide"</span>,
                       batchCol = <span class="st">"Set"</span>)</pre></div>
<p>The computed CVs are stored in the <code>colData</code> of the <code>peptides_filter1</code> assay and holds the median CV per cell computed using at least 5 observations (peptides). The main interest of computing the median CV per cell is to filter cells with reliable quantification. The blank samples are not expected to have reliable quantifications and hence can be used to estimate an empirical null distribution of the CV. This distribution helps defining a threshold that filters out single-cells that contain noisy quantification.</p>
<div class="sourceCode" id="cb31"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]] <span class="op">%&gt;%</span>
  <span class="kw">colData</span> <span class="op">%&gt;%</span>
  <span class="kw">data.frame</span> <span class="op">%&gt;%</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(x = <span class="kw">.MedianCV</span>,
             fill = <span class="kw">SampleType</span>)) <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_boxplot.html">geom_boxplot</a></span>() <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span>(xintercept = <span class="fl">0.3</span>)</pre></div>
<p><img src="scp_files/figure-html/plot_medianCV-1.png" width="700"></p>
<p>We can see that the protein quantifiation for single-cells are much more consistent within cells than witin the blank channels. Based on the distribution of the blanks, we decide to keep the cells that have a median CV lower than 0.3. Note this example is inaccurate because the null distribution is based on only 3 blank samples, but more sets could lead to a better estimation of the CV null distribution. Note we also keep only the samples of interest (macrophages and monocytes) since all QC metrics are now computed.</p>
<div class="sourceCode" id="cb32"><pre class="downlit">
<span class="kw">keepSample</span> <span class="op">&lt;-</span> <span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]]<span class="op">$</span><span class="kw">.MedianCV</span> <span class="op">&lt;</span> <span class="fl">0.3</span> <span class="op">&amp;</span>
  <span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]]<span class="op">$</span><span class="kw">SampleType</span> <span class="op">%in%</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"Macrophage"</span>, <span class="st">"Monocyte"</span>)
<span class="kw">keepSample</span>[<span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(<span class="kw">keepSample</span>)] <span class="op">&lt;-</span> <span class="fl">FALSE</span></pre></div>
<p>Then, we subset the assay for samples that pass the filter.</p>
<div class="sourceCode" id="cb33"><pre class="downlit">
<span class="kw">sce</span> <span class="op">&lt;-</span> <span class="kw">scp</span>[[<span class="st">"peptides_filter1"</span>]]
<span class="kw">sce</span> <span class="op">&lt;-</span> <span class="kw">sce</span>[, <span class="kw">keepSample</span>]</pre></div>
<p>Finally, we add the filtered assay to the <code>QFeatures</code>object and created the required linking with the previous assay.</p>
<div class="sourceCode" id="cb34"><pre class="downlit">
<span class="fu">addAssay</span>(<span class="kw">scp</span>,
         y = <span class="kw">sce</span>,
         name = <span class="st">"peptides_filter2"</span>) <span class="op">%&gt;%</span>
  <span class="fu">addAssayLinkOneToOne</span>(from = <span class="st">"peptides_filter1"</span>,
                       to = <span class="st">"peptides_filter2"</span>) <span class="op">-&gt;</span>
  <span class="kw">scp</span></pre></div>
</div>
</div>
<div id="process-the-peptide-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-peptide-data" class="anchor"></a>Process the peptide data</h1>
<p>In this vignette, the peptide data are further processed before aggregation to proteins. The steps are: normalization, filter peptides based on missing data and log-transformation.</p>
<div id="normalization" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization" class="anchor"></a>Normalization</h2>
<p>The columns (samples) of the peptide data are first normalized by dividing the relative intensities by the median relative intensities. Then, the rows (peptides) are normalized by dividing the relative intensities by the mean relative intensities. The normalized data is stored in a separate assay. This normalization procedure is suggested in the SCoPE2 analysis and is applied using the <code>sweep</code> method. Beside the dataset and the assay to normalize, the method expects a <code>MARGIN</code>, that is either row-wise (<code>1</code>) or column-wise (<code>2</code>) transformation, the <code>FUN</code> function to apply and <code>STATS</code>, a vector of values to apply. More conventional normalization procedure can be found in <code><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">?QFeatures::normalize</a></code>.</p>
<div class="sourceCode" id="cb35"><pre class="downlit">
<span class="kw">scp</span> <span class="op">%&gt;%</span>
    <span class="co">## Divide columns by median</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span>(i = <span class="st">"peptides_filter2"</span>,
        MARGIN = <span class="fl">2</span>,
        FUN = <span class="st">"/"</span>,
        STATS = <span class="fu">colMedians</span>(<span class="fu">assay</span>(<span class="kw">scp</span>[[<span class="st">"peptides_filter2"</span>]]),
                           na.rm = <span class="fl">TRUE</span>),
        name = <span class="st">"peptides_norm_col"</span>) <span class="op">%&gt;%</span>
    <span class="co">## Divide rows by mean</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span>(i = <span class="st">"peptides_norm_col"</span>,
        MARGIN = <span class="fl">1</span>,
        FUN = <span class="st">"/"</span>,
        STATS = <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span>(<span class="fu">assay</span>(<span class="kw">.</span>[[<span class="st">"peptides_norm_col"</span>]]),
                         na.rm = <span class="fl">TRUE</span>),
        name = <span class="st">"peptides_norm"</span>) <span class="op">-&gt;</span>
    <span class="kw">scp</span></pre></div>
<p>Notice each call to <code>sweep</code> created a new assay.</p>
<div class="sourceCode" id="cb36"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 11 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  ...</span>
<span class="co">#&gt;  [9] peptides_filter2: SingleCellExperiment with 358 rows and 15 columns </span>
<span class="co">#&gt;  [10] peptides_norm_col: SingleCellExperiment with 358 rows and 15 columns </span>
<span class="co">#&gt;  [11] peptides_norm: SingleCellExperiment with 358 rows and 15 columns</span></pre></div>
</div>
<div id="remove-peptides-with-high-missing-rate" class="section level2">
<h2 class="hasAnchor">
<a href="#remove-peptides-with-high-missing-rate" class="anchor"></a>Remove peptides with high missing rate</h2>
<p>Peptides that contain many missing values are not informative. Therefore, another common procedure is to remove higly missing data. In this example, we remove peptides with more than 99 % missing data. This is done using the <code>filterNA</code> function from <code>QFeatures</code>.</p>
<div class="sourceCode" id="cb37"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">filterNA</span>(<span class="kw">scp</span>,
                i = <span class="st">"peptides_norm"</span>,
                pNA = <span class="fl">0.99</span>)</pre></div>
</div>
<div id="log-transformation" class="section level2">
<h2 class="hasAnchor">
<a href="#log-transformation" class="anchor"></a>Log-transformation</h2>
<p>In this vignette, we perform log2-transformation using the <code>logTransform</code> method from <code>QFeatures</code>. Other log-transformation can be applied by changing the <code>base</code> argument.</p>
<div class="sourceCode" id="cb38"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">logTransform</span>(<span class="kw">scp</span>,
                    base = <span class="fl">2</span>,
                    i = <span class="st">"peptides_norm"</span>,
                    name = <span class="st">"peptides_log"</span>)</pre></div>
<p>Similarly to <code>sweep</code>, <code>logTransform</code> creates a new assay in <code>scp</code>.</p>
</div>
</div>
<div id="aggregate-peptide-data-to-protein-data" class="section level1">
<h1 class="hasAnchor">
<a href="#aggregate-peptide-data-to-protein-data" class="anchor"></a>Aggregate peptide data to protein data</h1>
<p>Similarly to aggregating PSM data to peptide data, we can aggregate peptide data to protein data using the <code>aggregateFeatures</code> function.</p>
<div class="sourceCode" id="cb39"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">aggregateFeatures</span>(<span class="kw">scp</span>,
                         i = <span class="st">"peptides_log"</span>,
                         name = <span class="st">"proteins"</span>,
                         fcol = <span class="st">"protein"</span>,
                         fun = <span class="kw">matrixStats</span>::<span class="kw"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>, na.rm = <span class="fl">TRUE</span>)
<span class="co">#&gt; Your quantitative and row data contain missing values. Please read the</span>
<span class="co">#&gt; relevant section(s) in the aggregateFeatures manual page regarding the</span>
<span class="co">#&gt; effects of missing values on data aggregation.</span></pre></div>
<p>The only difference between <code>aggregateFeatures</code> and <code>aggregateFeaturesOverAssays</code> is that the second function can aggregate several assay at once whereas the former only takes one assay to aggregate. Hence, only a single assay, <code>proteins</code>, was created in the <code>scp</code> object.</p>
<div class="sourceCode" id="cb40"><pre class="downlit">
<span class="kw">scp</span>
<span class="co">#&gt; An instance of class QFeatures containing 13 assays:</span>
<span class="co">#&gt;  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 216 rows and 16 columns </span>
<span class="co">#&gt;  [2] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 240 rows and 16 columns </span>
<span class="co">#&gt;  [3] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 142 rows and 16 columns </span>
<span class="co">#&gt;  ...</span>
<span class="co">#&gt;  [11] peptides_norm: SingleCellExperiment with 348 rows and 15 columns </span>
<span class="co">#&gt;  [12] peptides_log: SingleCellExperiment with 348 rows and 15 columns </span>
<span class="co">#&gt;  [13] proteins: SingleCellExperiment with 89 rows and 15 columns</span></pre></div>
<p>After the second aggregation, the <code>proteins</code> assay in this example contains quantitative information for 89 proteins in 15 single-cells.</p>
</div>
<div id="process-the-protein-data" class="section level1">
<h1 class="hasAnchor">
<a href="#process-the-protein-data" class="anchor"></a>Process the protein data</h1>
<p>The protein data is further processed in three steps: normalization, imputation (using the KNN algorithm) and batch correction (using the <code>ComBat</code> algorithm).</p>
<div id="normalization-1" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-1" class="anchor"></a>Normalization</h2>
<p>Normalization is performed similarly to peptide normalization. We use the same functions, but since the data were log-transformed at the peptide level, we subtract by the statistic (median or mean) instead of dividing.</p>
<div class="sourceCode" id="cb41"><pre class="downlit">
<span class="kw">scp</span> <span class="op">%&gt;%</span>
    <span class="co">## Center columns with median</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span>(i = <span class="st">"proteins"</span>,
          MARGIN = <span class="fl">2</span>,
          FUN = <span class="st">"-"</span>,
          STATS = <span class="fu">colMedians</span>(<span class="fu">assay</span>(<span class="kw">scp</span>[[<span class="st">"proteins"</span>]]),
                             na.rm = <span class="fl">TRUE</span>),
          name = <span class="st">"proteins_norm_col"</span>) <span class="op">%&gt;%</span>
    <span class="co">## Center rows with mean</span>
    <span class="fu"><a href="https://rdrr.io/r/base/sweep.html">sweep</a></span>(i = <span class="st">"proteins_norm_col"</span>,
          MARGIN = <span class="fl">1</span>,
          FUN = <span class="st">"-"</span>,
          STATS = <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span>(<span class="fu">assay</span>(<span class="kw">.</span>[[<span class="st">"proteins_norm_col"</span>]]),
                           na.rm = <span class="fl">TRUE</span>),
          name = <span class="st">"proteins_norm"</span>) <span class="op">-&gt;</span>
    <span class="kw">scp</span></pre></div>
</div>
<div id="imputation" class="section level2">
<h2 class="hasAnchor">
<a href="#imputation" class="anchor"></a>Imputation</h2>
<p>The protein data contains a lot of missing values.</p>
<div class="sourceCode" id="cb42"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"proteins_norm"</span>]] <span class="op">%&gt;%</span>
  <span class="kw">assay</span> <span class="op">%&gt;%</span>
  <span class="kw">is.na</span> <span class="op">%&gt;%</span>
  <span class="kw">mean</span>
<span class="co">#&gt; [1] 0.2606742</span></pre></div>
<p>The average missingness in the <code>proteins</code> assay is around 25 %. Including more samples and hence more batches can increase the missingness up to 70 % as seen for the complete SCoPE2 dataset (<span class="citation">Specht et al. (2019)</span>). Whether imputation is beneficial or deleterious for the data will not be discussed in this vignette. But taking those missing value into account is essential to avoid artefacts in downstream analyses. The data imputation is performed using the K nearest neighbors algorithm, with k = 3. This is available from the <code>impute</code> mehtod. More details about the arguments can be found in <code><a href="https://rdrr.io/pkg/impute/man/impute.knn.html">?impute::impute.knn</a></code>.</p>
<div class="sourceCode" id="cb43"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu">impute</span>(<span class="kw">scp</span>,
              i = <span class="st">"proteins_norm"</span>,
              method = <span class="st">"knn"</span>,
              k = <span class="fl">3</span>, rowmax = <span class="fl">1</span>, colmax= <span class="fl">1</span>,
              maxp = <span class="fl">Inf</span>, rng.seed = <span class="fl">1234</span>)
<span class="co">#&gt; Loading required namespace: impute</span></pre></div>
<p>Note that after imputation, no value are missing.</p>
<div class="sourceCode" id="cb44"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"proteins_norm"</span>]] <span class="op">%&gt;%</span>
  <span class="kw">assay</span> <span class="op">%&gt;%</span>
  <span class="kw">is.na</span> <span class="op">%&gt;%</span>
  <span class="kw">mean</span>
<span class="co">#&gt; [1] 0</span></pre></div>
</div>
<div id="batch-correction" class="section level2">
<h2 class="hasAnchor">
<a href="#batch-correction" class="anchor"></a>Batch correction</h2>
<p>A very important step for processing SCP data is to correct for batch effects. Batch effects are caused by technical variation occuring during different MS runs. Since only a small number of single-cells can be acquired at once, batch effects are unavoidable.</p>
<p>The <code>ComBat</code> function from the <code>sva</code> package can be used to perform batch correction as it is performed in the SCoPE2 analysis. We do not claim that <code>ComBat</code> is the best algorithm for batch correcting SCP data and other batch correcting methods could be used using the same procedure.</p>
<p>We first extract the assay to process.</p>
<div class="sourceCode" id="cb45"><pre class="downlit">
<span class="kw">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/transferColDataToAssay.html">transferColDataToAssay</a></span>(<span class="kw">scp</span>, i = <span class="st">"proteins_norm"</span>)
<span class="kw">sce</span> <span class="op">&lt;-</span> <span class="kw">scp</span>[[<span class="st">"proteins_norm"</span>]]</pre></div>
<p>Next, we need to provide a design matrix and the batch annotation to <code>Combat</code>. The design matrix allows to protect variables of interest, in our case <code>SampleType</code>.</p>
<div class="sourceCode" id="cb46"><pre class="downlit">
<span class="kw">batch</span> <span class="op">&lt;-</span> <span class="fu">colData</span>(<span class="kw">sce</span>)<span class="op">$</span><span class="kw">Set</span>
<span class="kw">model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html">model.matrix</a></span>(<span class="op">~</span> <span class="kw">SampleType</span>, data = <span class="fu">colData</span>(<span class="kw">sce</span>))</pre></div>
<p>We then load and call <code>ComBat</code> and overwrite the data matrix. Recall the data matrix can be accessed using the <code>assay</code> function.</p>
<div class="sourceCode" id="cb47"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw">sva</span>)
<span class="fu">assay</span>(<span class="kw">sce</span>) <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sva/man/ComBat.html">ComBat</a></span>(dat = <span class="fu">assay</span>(<span class="kw">sce</span>),
                     batch = <span class="kw">batch</span>,
                     mod = <span class="kw">model</span>)</pre></div>
<p>Finally, we add the batch corrected assay to the <code>QFeatures</code> object and create the feature links.</p>
<div class="sourceCode" id="cb48"><pre class="downlit">
<span class="fu">addAssay</span>(<span class="kw">scp</span>,
         y = <span class="kw">sce</span>,
         name = <span class="st">"proteins_batchC"</span>) <span class="op">%&gt;%</span>
  <span class="fu">addAssayLinkOneToOne</span>(from = <span class="st">"proteins_norm"</span>,
                       to = <span class="st">"proteins_batchC"</span>) <span class="op">-&gt;</span>
  <span class="kw">scp</span></pre></div>
</div>
</div>
<div id="dimension-reduction" class="section level1">
<h1 class="hasAnchor">
<a href="#dimension-reduction" class="anchor"></a>Dimension reduction</h1>
<p>Because each assay contains <code>SingelCellExperiment</code> objects, we can easily apply methods developed in the scRNA-Seq field. A useful package for dimension reduction on single-cell data is the <code>scater</code>.</p>
<div class="sourceCode" id="cb49"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="kw"><a href="http://bioconductor.org/packages/scater/">scater</a></span>)
<span class="co">#&gt; Loading required package: SingleCellExperiment</span></pre></div>
<p>This package provides streamline functions to computes various dimension reduction such as PCA, UMAP, t-SNE, NMF, MDS, ….</p>
<div id="pca" class="section level2">
<h2 class="hasAnchor">
<a href="#pca" class="anchor"></a>PCA</h2>
<p>PCA can be computed using the <code>runPCA</code> method. It returns a <code>SingleCellExperiment</code> object for which the dimension reduction results are stored in the <code>reducedDim</code> slot.</p>
<div class="sourceCode" id="cb50"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]] <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scater/man/runPCA.html">runPCA</a></span>(<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]],
                                   ncomponents = <span class="fl">50</span>,
                                   ntop = <span class="fl">Inf</span>,
                                   scale = <span class="fl">TRUE</span>,
                                   exprs_values = <span class="fl">1</span>,
                                   name = <span class="st">"PCA"</span>)</pre></div>
<p>The computed PCA can be displayed using the <code>plotReducedDim</code> function. The <code>dimred</code> arguments should give the name of the dimension reduction results to plot, here we called it <code>PCA</code>. The samples are colored by type of sample.</p>
<div class="sourceCode" id="cb51"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/pkg/scater/man/plotReducedDim.html">plotReducedDim</a></span>(<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]],
               dimred = <span class="st">"PCA"</span>,
               colour_by = <span class="st">"SampleType"</span>)</pre></div>
<p><img src="scp_files/figure-html/plot_PCA-1.png" width="700"></p>
<p>This is a minimalistic example with only a few plotted cells, but the original SCoPE2 dataset contained more than thousand cells.</p>
</div>
<div id="umap" class="section level2">
<h2 class="hasAnchor">
<a href="#umap" class="anchor"></a>UMAP</h2>
<p>Similarly to PCA, we can compute a UMAP using the <code>runUMAP</code> method. Note however that the UMAP implementation requires a initialization, usually provided by PCA. The previous PCA results are used automatically when supplying <code>dimred = "PCA"</code> (<code>PCA</code> is the name of the dimension reduction result that we supplied in the previous section).</p>
<div class="sourceCode" id="cb52"><pre class="downlit">
<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]] <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scater/man/runUMAP.html">runUMAP</a></span>(<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]],
                                    ncomponents = <span class="fl">2</span>,
                                    ntop = <span class="fl">Inf</span>,
                                    scale = <span class="fl">TRUE</span>,
                                    exprs_values = <span class="fl">1</span>,
                                    n_neighbors = <span class="fl">3</span>,
                                    dimred = <span class="st">"PCA"</span>,
                                    name = <span class="st">"UMAP"</span>)</pre></div>
<p>The computed UMAP can be displayed using the <code>plotReducedDim</code> function. The <code>dimred</code> arguments gives the name of the dimension reduction results to plot, here we called it <code>UMAP</code>. The samples are colored by type of sample.</p>
<div class="sourceCode" id="cb53"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/pkg/scater/man/plotReducedDim.html">plotReducedDim</a></span>(<span class="kw">scp</span>[[<span class="st">"proteins_batchC"</span>]],
               dimred = <span class="st">"UMAP"</span>,
               colour_by = <span class="st">"SampleType"</span>)</pre></div>
<p><img src="scp_files/figure-html/plot_UMAP-1.png" width="700"></p>
<p>The UMAP plot is a very interesting plot for large datasets. A UMAP on this small example dataset is not useful but is shown for illustration.</p>
</div>
</div>
<div id="monitoring-data-processing" class="section level1">
<h1 class="hasAnchor">
<a href="#monitoring-data-processing" class="anchor"></a>Monitoring data processing</h1>
<p>The <code>QFeatures</code> plot shows the quantitative data for a features at the different expression levels. For instance, suppose we are interested in the protein <em>LMNA</em> (protein ID is <code>P02545</code>). A useful QC is to monitor the data processing at the PSM, peptide and protein level. This can easily be done thanks to the <code>QFeatures</code> framework. Using the <code>subsetByFeature</code>, we can extract the protein of interest and its related features in the other assays. The data is formated to a long format table that can easily be plugged in the <code>ggplot2</code> visualization tool.</p>
<div class="sourceCode" id="cb54"><pre class="downlit">
<span class="kw">scp</span> <span class="op">%&gt;%</span>
  <span class="co">## Get the features related to LMNA (P02545)</span>
  <span class="fu">subsetByFeature</span>(<span class="st">"P02545"</span>) <span class="op">%&gt;%</span>
  <span class="co">## Format the `QFeatures` to a long format table</span>
  <span class="fu">longFormat</span>(colDataCols = <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"Set"</span>, <span class="st">"SampleType"</span>, <span class="st">"Channel"</span>)) <span class="op">%&gt;%</span>
  <span class="kw">data.frame</span> <span class="op">%&gt;%</span>
  <span class="co">## This is used to preserve ordering of the samples and assays in ggplot2</span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span>(assay = <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span>(<span class="kw">assay</span>, levels = <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span>(<span class="kw">scp</span>)),
         Channel = <span class="fu"><a href="https://rdrr.io/r/base/grep.html">sub</a></span>(<span class="st">"RI"</span>, <span class="st">"TMT-"</span>, <span class="kw">Channel</span>),
         Channel = <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span>(<span class="kw">Channel</span>, levels = <span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span>(<span class="kw">Channel</span>))) <span class="op">%&gt;%</span>
  <span class="co">## Start plotting</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span>(<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span>(x = <span class="kw">Channel</span>, y = <span class="kw">value</span>, group = <span class="kw">rowname</span>, col = <span class="kw">SampleType</span>)) <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span>() <span class="op">+</span>
  <span class="co">## Plot every assay in a separate facet</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html">facet_wrap</a></span>(facets = <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/vars.html">vars</a></span>(<span class="kw">assay</span>), scales = <span class="st">"free_y"</span>, ncol = <span class="fl">3</span>) <span class="op">+</span>
  <span class="co">## Annotate plot</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">xlab</a></span>(<span class="st">"Channels"</span>) <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">ylab</a></span>(<span class="st">"Intensity (arbitrary units)"</span>) <span class="op">+</span>
  <span class="co">## Improve plot aspect</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html">theme</a></span>(axis.text.x = <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html">element_text</a></span>(angle = <span class="fl">90</span>),
        strip.text = <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html">element_text</a></span>(hjust = <span class="fl">0</span>),
        legend.position = <span class="st">"bottom"</span>)</pre></div>
<p><img src="scp_files/figure-html/monitor_plot-1.png" width="100%"></p>
<p>This graph helps to keep track of the data processing and highlights anomalies in the data. For instance, we can see that no data were recorded for 5 channels (TMT-12 to 16). Those channels contain either macrophages or monocytes (from the experimental design) and are expected to contain information. Thanks to this diagnostic plot, we reported the issue to Specht and colleagues and this led to version 3 of the SCoPE2 dataset.</p>
</div>
<div id="session-information" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session information</h1>
<pre><code>R version 4.0.2 Patched (2020-09-02 r79126)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.1 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-openmp/libopenblasp-r0.3.8.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] scater_1.17.4               SingleCellExperiment_1.11.6
 [3] sva_3.37.0                  BiocParallel_1.23.2        
 [5] genefilter_1.71.0           mgcv_1.8-33                
 [7] nlme_3.1-149                dplyr_1.0.2                
 [9] magrittr_1.5                ggplot2_3.3.2              
[11] scp_0.99.2                  QFeatures_0.99.2           
[13] MultiAssayExperiment_1.15.3 SummarizedExperiment_1.19.6
[15] DelayedArray_0.15.7         matrixStats_0.56.0         
[17] Matrix_1.2-18               Biobase_2.49.1             
[19] GenomicRanges_1.41.6        GenomeInfoDb_1.25.11       
[21] IRanges_2.23.10             S4Vectors_0.27.12          
[23] BiocGenerics_0.35.4         BiocStyle_2.17.0           

loaded via a namespace (and not attached):
 [1] ProtGenerics_1.21.0       bitops_1.0-6             
 [3] fs_1.5.0                  bit64_4.0.5              
 [5] rprojroot_1.3-2           tools_4.0.2              
 [7] backports_1.1.9           irlba_2.3.3              
 [9] R6_2.4.1                  vipor_0.4.5              
[11] uwot_0.1.8                DBI_1.1.0                
[13] lazyeval_0.2.2            colorspace_1.4-1         
[15] withr_2.2.0               gridExtra_2.3            
[17] tidyselect_1.1.0          bit_4.0.4                
[19] compiler_4.0.2            BiocNeighbors_1.7.0      
[21] desc_1.2.0                labeling_0.3             
[23] bookdown_0.20             scales_1.1.1             
[25] pkgdown_1.6.0.9000        systemfonts_0.3.0        
[27] stringr_1.4.0             digest_0.6.25            
[29] rmarkdown_2.3             XVector_0.29.3           
[31] pkgconfig_2.0.3           htmltools_0.5.0          
[33] limma_3.45.13             highr_0.8                
[35] rlang_0.4.7               RSQLite_2.2.0            
[37] impute_1.63.0             FNN_1.1.3                
[39] DelayedMatrixStats_1.11.1 farver_2.0.3             
[41] generics_0.0.2            BiocSingular_1.5.0       
[43] RCurl_1.98-1.2            scuttle_0.99.13          
[45] GenomeInfoDbData_1.2.3    ggbeeswarm_0.6.0         
[47] Rcpp_1.0.5                munsell_0.5.0            
[49] viridis_0.5.1             MsCoreUtils_1.1.3        
[51] lifecycle_0.2.0           stringi_1.4.6            
[53] yaml_2.2.1                edgeR_3.31.4             
[55] MASS_7.3-52               zlibbioc_1.35.0          
[57] grid_4.0.2                blob_1.2.1               
[59] crayon_1.3.4              lattice_0.20-41          
[61] splines_4.0.2             annotate_1.67.1          
[63] locfit_1.5-9.4            knitr_1.29               
[65] pillar_1.4.6              XML_3.99-0.5             
[67] glue_1.4.2                evaluate_0.14            
[69] BiocManager_1.30.10       vctrs_0.3.4              
[71] gtable_0.3.0              purrr_0.3.4              
[73] assertthat_0.2.1          cpp11_0.2.1              
[75] xfun_0.16                 rsvd_1.0.3               
[77] xtable_1.8-4              AnnotationFilter_1.13.0  
[79] RSpectra_0.16-0           viridisLite_0.3.0        
[81] ragg_0.3.1                survival_3.2-3           
[83] tibble_3.0.3              beeswarm_0.2.3           
[85] AnnotationDbi_1.51.3      memoise_1.1.0            
[87] ellipsis_0.3.1           </code></pre>
</div>
<div id="reference" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#reference" class="anchor"></a>Reference</h1>
<div id="refs" class="references">
<div id="ref-Cox:2008">
<p>Cox, J, and M Mann. 2008. “MaxQuant Enables High Peptide Identification Rates, Individualized P.p.b.-range Mass Accuracies and Proteome-Wide Protein Quantification.” <em>Nat Biotechnol</em> 26 (12): 1367–72. <a href="https://doi.org/10.1038/nbt.1511">https://doi.org/10.1038/nbt.1511</a>.</p>
</div>
<div id="ref-QFeatures">
<p>Gatto, Laurent. 2020. <em>QFeatures: Quantitative Features for Mass Spectrometry Data</em>. <a href="https://github.com/RforMassSpectrometry/QFeatures">https://github.com/RforMassSpectrometry/QFeatures</a>.</p>
</div>
<div id="ref-Kall2008-hb">
<p>Käll, Lukas, John D Storey, Michael J MacCoss, and William Stafford Noble. 2008. “Posterior Error Probabilities and False Discovery Rates: Two Sides of the Same Coin.” <em>J. Proteome Res.</em> 7 (1): 40–44.</p>
</div>
<div id="ref-sce">
<p>Lun, Aaron, and Davide Risso. 2020. <em>SingleCellExperiment: S4 Classes for Single Cell Data</em>.</p>
</div>
<div id="ref-Specht2019-jm">
<p>Specht, Harrison, Edward Emmott, Toni Koller, and Nikolai Slavov. 2019. “High-Throughput Single-Cell Proteomics Quantifies the Emergence of Macrophage Heterogeneity.” <em>bioRxiv</em>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Christophe Vanderaa, Laurent Gatto.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.0.9000.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
